




# ==== README.md ====

# AITTC Experimental Farm Management System

## Project Overview
This project digitizes the paper-based management system of the AITTC Experimental Farm, providing a comprehensive web application for field reservations, project management, inventory tracking, and administrative workflows.

## Objectives
- Enable external clients to register and request field reservations
- Provide admin control over users, fields, projects, inventory, and documents
- Track real-time field utilization and project status
- Digitize forms F.10 (inventory), F.47 (price offers), and F.84 (service orders)
- Implement role-based access control (Admin, Supervisor, Client)

## System Architecture

### Technology Stack
- **Backend**: Node.js with Express.js
- **Database**: PostgreSQL with Prisma ORM
- **Frontend**: React with TypeScript
- **Authentication**: JWT with email verification
- **File Storage**: Local file system for PDF generation
- **Email**: Nodemailer for notifications

### Database Schema
The system uses a relational database with the following core entities:
- Users (Admin, Supervisor, Client roles)
- Entities (organizations)
- Fields (with surface area tracking)
- Projects (linked to fields and users)
- Reservations (client requests)
- ActivityTypes (categorization)
- InventoryItems (F.10 form data)
- PriceOffers (F.47 form data)
- ServiceOrders (F.84 form data)

## Installation and Setup

### Prerequisites
- Node.js 18+
- PostgreSQL 14+
- npm or yarn

### Installation Steps
1. Clone the repository
2. Install dependencies: `npm install`
3. Set up environment variables (see `.env.example`)
4. Run database migrations: `npm run db:migrate`
5. Seed initial data: `npm run db:seed`
6. Start the development server: `npm run dev`

## User Roles and Permissions

### Admin
- Full CRUD access to all entities
- Approve/reject reservations
- Assign supervisors to projects
- Manage inventory and alerts
- Generate reports and exports

### Supervisor
- View assigned projects
- Update project status and progress
- Cannot modify approvals or field allocations

### Client
- Register with email verification
- Submit field reservation requests
- View own reservations and projects
- Cannot access other users' data

## Core Features

### Field Management
- Real-time surface area tracking
- Visual utilization indicators
- Status management (Active/Inactive)
- Location and notes

### Reservation System
- Client request workflow
- Admin approval/rejection
- Automatic surface area deduction
- Supervisor assignment

### Project Tracking
- Timeline visualization
- Status updates (En cours, Finalis√©, Programme, A lancer)
- Progress notes and documentation

### Document Management
- Digital forms for F.10, F.47, F.84
- PDF generation and archiving
- Search and filtering capabilities
- Export functionality (CSV/PDF)

### Inventory Management
- Stock tracking with alerts
- Condition monitoring
- Location management
- Weekly inventory updates

## Business Rules
- Reservations cannot exceed available field surface
- Project completion releases surface area back to fields
- Fields with active projects cannot be deleted
- Inventory alerts for non-conforming items
- Form versioning for audit trails

## API Documentation
The system provides RESTful APIs for all operations with proper authentication and authorization.

## Testing
Comprehensive test suite covering:
- User authentication and authorization
- Business rule validation
- API endpoints
- User workflows
- Data integrity

## Deployment
The application can be deployed using Docker containers with proper environment configuration.

## Support
For technical support or questions, please contact the development team. 

# ==== .env ====

# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/aittc_farm_db"

# Server Configuration
PORT=3001
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here
JWT_EXPIRES_IN=7d

# Email Configuration (for verification and notifications)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASS=your-app-password
EMAIL_FROM=AITTC Farm Management <noreply@aittc.ma>

# File Upload Configuration
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Admin Default Account
ADMIN_EMAIL=admin@aittc.ma
ADMIN_PASSWORD=admin123
ADMIN_NAME=System Administrator

# Application URLs
FRONTEND_URL=http://localhost:3000
BACKEND_URL=http://localhost:3001 

# ==== env.example ====

# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/aittc_farm_db"

# Server Configuration
PORT=3001
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here
JWT_EXPIRES_IN=7d

# Email Configuration (for verification and notifications)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASS=your-app-password
EMAIL_FROM=AITTC Farm Management <noreply@aittc.ma>

# File Upload Configuration
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Admin Default Account
ADMIN_EMAIL=admin@aittc.ma
ADMIN_PASSWORD=admin123
ADMIN_NAME=System Administrator

# Application URLs
FRONTEND_URL=http://localhost:3000
BACKEND_URL=http://localhost:3001 

# ==== combine_code.py ====

import os

# Directories to exclude
EXCLUDE_DIRS = {
    'node_modules', 'venv', 'env', '__pycache__', '.git', '.next', 'dist', 'build', 'packages', '.turbo', '.cache'
}
# File extensions to EXCLUDE
EXCLUDE_EXTS = {
    '.json', '.pdf', '.txt'
}

def should_include_file(filename):
    return not any(filename.endswith(ext) for ext in EXCLUDE_EXTS)

def main(root_dir, output_file):
    with open(output_file, 'w', encoding='utf-8') as out:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Remove excluded directories in-place
            dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]
            for filename in filenames:
                if should_include_file(filename):
                    rel_path = os.path.relpath(os.path.join(dirpath, filename), root_dir)
                    out.write(f"\n\n# ==== {rel_path} ====\n\n")
                    with open(os.path.join(dirpath, filename), 'r', encoding='utf-8', errors='ignore') as f:
                        out.write(f.read())

if __name__ == "__main__":
    # Change '.' to your project root if needed
    main('.', 'all_code_combined.txt')

# ==== prisma/schema.prisma ====

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User management
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String
  name          String
  role          UserRole @default(CLIENT)
  entityId      String?
  isVerified    Boolean  @default(false)
  verificationToken String?
  resetToken    String?
  resetTokenExpiry DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  entity        Entity?  @relation(fields: [entityId], references: [id])
  clientReservations Reservation[] @relation("ClientReservations")
  supervisorReservations Reservation[] @relation("SupervisorReservations")
  supervisorProjects Project[] @relation("SupervisorProjects")
  clientProjects Project[] @relation("ClientProjects")
  createdPriceOffers PriceOffer[] @relation("CreatedBy")
  createdServiceOrders ServiceOrder[] @relation("CreatedBy")

  @@map("users")
}

model Entity {
  id          String   @id @default(cuid())
  name        String
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users       User[]

  @@map("entities")
}

// Field and project management
model Field {
  id              String   @id @default(cuid())
  name            String
  location        String
  totalSurfaceM2  Float
  freeSurfaceM2   Float
  status          FieldStatus @default(ACTIVE)
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  projects        Project[]
  reservations    Reservation[]

  @@map("fields")
}

model ActivityType {
  id          String   @id @default(cuid())
  label       String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  projects    Project[]

  @@map("activity_types")
}

model Project {
  id              String        @id @default(cuid())
  title           String
  fieldId         String
  clientId        String
  supervisorId    String
  activityTypeId  String?
  surfaceM2       Float
  startDate       DateTime
  endDate         DateTime?
  status          ProjectStatus @default(A_LANCER)
  progressNotes   String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  field           Field         @relation(fields: [fieldId], references: [id])
  client          User          @relation("ClientProjects", fields: [clientId], references: [id])
  supervisor      User          @relation("SupervisorProjects", fields: [supervisorId], references: [id])
  activityType    ActivityType? @relation(fields: [activityTypeId], references: [id])

  @@map("projects")
}



# ==== README.md ====

# AITTC Experimental Farm Management System

## Project Overview
This project digitizes the paper-based management system of the AITTC Experimental Farm, providing a comprehensive web application for field reservations, project management, inventory tracking, and administrative workflows.

## Objectives
- Enable external clients to register and request field reservations
- Provide admin control over users, fields, projects, inventory, and documents
- Track real-time field utilization and project status
- Digitize forms F.10 (inventory), F.47 (price offers), and F.84 (service orders)
- Implement role-based access control (Admin, Supervisor, Client)

## System Architecture

### Technology Stack
- **Backend**: Node.js with Express.js
- **Database**: PostgreSQL with Prisma ORM
- **Frontend**: React with TypeScript
- **Authentication**: JWT with email verification
- **File Storage**: Local file system for PDF generation
- **Email**: Nodemailer for notifications

### Database Schema
The system uses a relational database with the following core entities:
- Users (Admin, Supervisor, Client roles)
- Entities (organizations)
- Fields (with surface area tracking)
- Projects (linked to fields and users)
- Reservations (client requests)
- ActivityTypes (categorization)
- InventoryItems (F.10 form data)
- PriceOffers (F.47 form data)
- ServiceOrders (F.84 form data)

## Installation and Setup

### Prerequisites
- Node.js 18+
- PostgreSQL 14+
- npm or yarn

### Installation Steps
1. Clone the repository
2. Install dependencies: `npm install`
3. Set up environment variables (see `.env.example`)
4. Run database migrations: `npm run db:migrate`
5. Seed initial data: `npm run db:seed`
6. Start the development server: `npm run dev`

## User Roles and Permissions

### Admin
- Full CRUD access to all entities
- Approve/reject reservations
- Assign supervisors to projects
- Manage inventory and alerts
- Generate reports and exports

### Supervisor
- View assigned projects
- Update project status and progress
- Cannot modify approvals or field allocations

### Client
- Register with email verification
- Submit field reservation requests
- View own reservations and projects
- Cannot access other users' data

## Core Features

### Field Management
- Real-time surface area tracking
- Visual utilization indicators
- Status management (Active/Inactive)
- Location and notes

### Reservation System
- Client request workflow
- Admin approval/rejection
- Automatic surface area deduction
- Supervisor assignment

### Project Tracking
- Timeline visualization
- Status updates (En cours, Finalis√©, Programme, A lancer)
- Progress notes and documentation

### Document Management
- Digital forms for F.10, F.47, F.84
- PDF generation and archiving
- Search and filtering capabilities
- Export functionality (CSV/PDF)

### Inventory Management
- Stock tracking with alerts
- Condition monitoring
- Location management
- Weekly inventory updates

## Business Rules
- Reservations cannot exceed available field surface
- Project completion releases surface area back to fields
- Fields with active projects cannot be deleted
- Inventory alerts for non-conforming items
- Form versioning for audit trails

## API Documentation
The system provides RESTful APIs for all operations with proper authentication and authorization.

## Testing
Comprehensive test suite covering:
- User authentication and authorization
- Business rule validation
- API endpoints
- User workflows
- Data integrity

## Deployment
The application can be deployed using Docker containers with proper environment configuration.

## Support
For technical support or questions, please contact the development team. 

# ==== .env ====

# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/aittc_farm_db"

# Server Configuration
PORT=3001
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here
JWT_EXPIRES_IN=7d

# Email Configuration (for verification and notifications)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASS=your-app-password
EMAIL_FROM=AITTC Farm Management <noreply@aittc.ma>

# File Upload Configuration
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Admin Default Account
ADMIN_EMAIL=admin@aittc.ma
ADMIN_PASSWORD=admin123
ADMIN_NAME=System Administrator

# Application URLs
FRONTEND_URL=http://localhost:3000
BACKEND_URL=http://localhost:3001 

# ==== env.example ====

# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/aittc_farm_db"

# Server Configuration
PORT=3001
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here
JWT_EXPIRES_IN=7d

# Email Configuration (for verification and notifications)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASS=your-app-password
EMAIL_FROM=AITTC Farm Management <noreply@aittc.ma>

# File Upload Configuration
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Admin Default Account
ADMIN_EMAIL=admin@aittc.ma
ADMIN_PASSWORD=admin123
ADMIN_NAME=System Administrator

# Application URLs
FRONTEND_URL=http://localhost:3000
BACKEND_URL=http://localhost:3001 

# ==== combine_code.py ====

import os

# Directories to exclude
EXCLUDE_DIRS = {
    'node_modules', 'venv', 'env', '__pycache__', '.git', '.next', 'dist', 'build', 'packages', '.turbo', '.cache'
}
# File extensions to EXCLUDE
EXCLUDE_EXTS = {
    '.json', '.pdf', '.txt'
}

def should_include_file(filename):
    return not any(filename.endswith(ext) for ext in EXCLUDE_EXTS)

def main(root_dir, output_file):
    with open(output_file, 'w', encoding='utf-8') as out:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Remove excluded directories in-place
            dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]
            for filename in filenames:
                if should_include_file(filename):
                    rel_path = os.path.relpath(os.path.join(dirpath, filename), root_dir)
                    out.write(f"\n\n# ==== {rel_path} ====\n\n")
                    with open(os.path.join(dirpath, filename), 'r', encoding='utf-8', errors='ignore') as f:
                        out.write(f.read())

if __name__ == "__main__":
    # Change '.' to your project root if needed
    main('.', 'all_code_combined.txt')

# ==== prisma/schema.prisma ====

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User management
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String
  name          String
  role          UserRole @default(CLIENT)
  entityId      String?
  isVerified    Boolean  @default(false)
  verificationToken String?
  resetToken    String?
  resetTokenExpiry DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  entity        Entity?  @relation(fields: [entityId], references: [id])
  clientReservations Reservation[] @relation("ClientReservations")
  supervisorReservations Reservation[] @relation("SupervisorReservations")
  supervisorProjects Project[] @relation("SupervisorProjects")
  clientProjects Project[] @relation("ClientProjects")
  createdPriceOffers PriceOffer[] @relation("CreatedBy")
  createdServiceOrders ServiceOrder[] @relation("CreatedBy")

  @@map("users")
}

model Entity {
  id          String   @id @default(cuid())
  name        String
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users       User[]

  @@map("entities")
}

// Field and project management
model Field {
  id              String   @id @default(cuid())
  name            String
  location        String
  totalSurfaceM2  Float
  freeSurfaceM2   Float
  status          FieldStatus @default(ACTIVE)
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  projects        Project[]
  reservations    Reservation[]

  @@map("fields")
}

model ActivityType {
  id          String   @id @default(cuid())
  label       String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  projects    Project[]

  @@map("activity_types")
}

model Project {
  id              String        @id @default(cuid())
  title           String
  fieldId         String
  clientId        String
  supervisorId    String
  activityTypeId  String?
  surfaceM2       Float
  startDate       DateTime
  endDate         DateTime?
  status          ProjectStatus @default(A_LANCER)
  progressNotes   String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  field           Field         @relation(fields: [fieldId], references: [id])
  client          User          @relation("ClientProjects", fields: [clientId], references: [id])
  supervisor      User          @relation("SupervisorProjects", fields: [supervisorId], references: [id])
  activityType    ActivityType? @relation(fields: [activityTypeId], references: [id])

  @@map("projects")
}

model Reservation {
  id                    String            @id @default(cuid())
  clientId              String
  fieldId               String
  surfaceM2Requested    Float
  startRequested        DateTime
  endRequested          DateTime
  status                ReservationStatus @default(PENDING)
  decisionDate          DateTime?
  supervisorId          String?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relations
  client                User              @relation("ClientReservations", fields: [clientId], references: [id])
  field                 Field             @relation(fields: [fieldId], references: [id])
  supervisor            User?             @relation("SupervisorReservations", fields: [supervisorId], references: [id])

  @@map("reservations")
}

// Document management (F.10, F.47, F.84)
model InventoryItem {
  id              String   @id @default(cuid())
  owner           String
  family          String
  subFamily       String?
  designation     String
  stockQty        Float
  unit            String
  condition       ItemCondition @default(OK)
  location        String
  lastChecked     DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("inventory_items")
}

model PriceOffer {
  id                String   @id @default(cuid())
  destinataire      String
  demandeur         String
  contact           String?
  address           String
  orderNumber       String?
  itemDesignation   String
  unit              String
  techDescription   String?
  quantity          Float
  dateSent          DateTime @default(now())
  status            OfferStatus @default(PENDING)
  createdById       String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  createdBy         User     @relation("CreatedBy", fields: [createdById], references: [id])

  @@map("price_offers")
}

model ServiceOrder {
  id              String   @id @default(cuid())
  objet           String
  marketNumber    String?
  bcNumber        String?
  startDate       DateTime
  clientRep       String
  supplier        String
  status          OrderStatus @default(IN_PROGRESS)
  dateNotified    DateTime @default(now())
  createdById     String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  createdBy       User     @relation("CreatedBy", fields: [createdById], references: [id])

  @@map("service_orders")
}

// Enums
enum UserRole {
  ADMIN
  SUPERVISOR
  CLIENT
}

enum FieldStatus {
  ACTIVE
  INACTIVE
}

enum ProjectStatus {
  EN_COURS
  FINALISE
  PROGRAMME
  A_LANCER
}

enum ReservationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ItemCondition {
  OK
  NON_CONFORME
  MAUVAIS
}

enum OfferStatus {
  PENDING
  SENT
  ACCEPTED
  REJECTED
}

enum OrderStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
} 

# ==== prisma/migrations/migration_lock.toml ====

# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

# ==== prisma/migrations/20250629151932_init/migration.sql ====

-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('ADMIN', 'SUPERVISOR', 'CLIENT');

-- CreateEnum
CREATE TYPE "FieldStatus" AS ENUM ('ACTIVE', 'INACTIVE');

-- CreateEnum
CREATE TYPE "ProjectStatus" AS ENUM ('EN_COURS', 'FINALISE', 'PROGRAMME', 'A_LANCER');

-- CreateEnum
CREATE TYPE "ReservationStatus" AS ENUM ('PENDING', 'APPROVED', 'REJECTED');

-- CreateEnum
CREATE TYPE "ItemCondition" AS ENUM ('OK', 'NON_CONFORME', 'MAUVAIS');

-- CreateEnum
CREATE TYPE "OfferStatus" AS ENUM ('PENDING', 'SENT', 'ACCEPTED', 'REJECTED');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('IN_PROGRESS', 'COMPLETED', 'CANCELLED');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "passwordHash" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "role" "UserRole" NOT NULL DEFAULT 'CLIENT',
    "entityId" TEXT,
    "isVerified" BOOLEAN NOT NULL DEFAULT false,
    "verificationToken" TEXT,
    "resetToken" TEXT,
    "resetTokenExpiry" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "entities" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "notes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "entities_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "fields" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "location" TEXT NOT NULL,
    "totalSurfaceM2" DOUBLE PRECISION NOT NULL,
    "freeSurfaceM2" DOUBLE PRECISION NOT NULL,
    "status" "FieldStatus" NOT NULL DEFAULT 'ACTIVE',
    "notes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "fields_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "activity_types" (
    "id" TEXT NOT NULL,
    "label" TEXT NOT NULL,
    "description" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "activity_types_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "projects" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "fieldId" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "supervisorId" TEXT NOT NULL,
    "activityTypeId" TEXT,
    "surfaceM2" DOUBLE PRECISION NOT NULL,
    "startDate" TIMESTAMP(3) NOT NULL,
    "endDate" TIMESTAMP(3),
    "status" "ProjectStatus" NOT NULL DEFAULT 'A_LANCER',
    "progressNotes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "projects_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "reservations" (
    "id" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "fieldId" TEXT NOT NULL,
    "surfaceM2Requested" DOUBLE PRECISION NOT NULL,
    "startRequested" TIMESTAMP(3) NOT NULL,
    "endRequested" TIMESTAMP(3) NOT NULL,
    "status" "ReservationStatus" NOT NULL DEFAULT 'PENDING',
    "decisionDate" TIMESTAMP(3),
    "supervisorId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "reservations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "inventory_items" (
    "id" TEXT NOT NULL,
    "owner" TEXT NOT NULL,
    "family" TEXT NOT NULL,
    "subFamily" TEXT,
    "designation" TEXT NOT NULL,
    "stockQty" DOUBLE PRECISION NOT NULL,
    "unit" TEXT NOT NULL,
    "condition" "ItemCondition" NOT NULL DEFAULT 'OK',
    "location" TEXT NOT NULL,
    "lastChecked" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "inventory_items_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "price_offers" (
    "id" TEXT NOT NULL,
    "destinataire" TEXT NOT NULL,
    "demandeur" TEXT NOT NULL,
    "contact" TEXT,
    "address" TEXT NOT NULL,
    "orderNumber" TEXT,
    "itemDesignation" TEXT NOT NULL,
    "unit" TEXT NOT NULL,
    "techDescription" TEXT,
    "quantity" DOUBLE PRECISION NOT NULL,
    "dateSent" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "status" "OfferStatus" NOT NULL DEFAULT 'PENDING',
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "price_offers_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "service_orders" (
    "id" TEXT NOT NULL,
    "objet" TEXT NOT NULL,
    "marketNumber" TEXT,
    "bcNumber" TEXT,
    "startDate" TIMESTAMP(3) NOT NULL,
    "clientRep" TEXT NOT NULL,
    "supplier" TEXT NOT NULL,
    "status" "OrderStatus" NOT NULL DEFAULT 'IN_PROGRESS',
    "dateNotified" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "service_orders_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "activity_types_label_key" ON "activity_types"("label");

-- AddForeignKey
ALTER TABLE "users" ADD CONSTRAINT "users_entityId_fkey" FOREIGN KEY ("entityId") REFERENCES "entities"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "projects" ADD CONSTRAINT "projects_fieldId_fkey" FOREIGN KEY ("fieldId") REFERENCES "fields"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "projects" ADD CONSTRAINT "projects_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "projects" ADD CONSTRAINT "projects_supervisorId_fkey" FOREIGN KEY ("supervisorId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "projects" ADD CONSTRAINT "projects_activityTypeId_fkey" FOREIGN KEY ("activityTypeId") REFERENCES "activity_types"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "reservations" ADD CONSTRAINT "reservations_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "reservations" ADD CONSTRAINT "reservations_fieldId_fkey" FOREIGN KEY ("fieldId") REFERENCES "fields"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "reservations" ADD CONSTRAINT "reservations_supervisorId_fkey" FOREIGN KEY ("supervisorId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "price_offers" ADD CONSTRAINT "price_offers_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "service_orders" ADD CONSTRAINT "service_orders_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


# ==== client/.env.local ====

REACT_APP_API_BASE_URL=http://localhost:3001/api


# ==== client/README.md ====

# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).


# ==== client/.gitignore ====

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


# ==== client/public/favicon.ico ====

           F          n  PNG

   
IHDR         (-S   PLTE""""""""""""""""""2PX=r)7;*:>H-BGE8do5Xb6[eKK1MU9gs3S\I:gt'03@{VTA}V@y6\fH-CIIE+;@7_i7_jFJKH-BHa,@FCL&.0WNI$)+BJR?v>s>uS=qPPP,?D4U^%+-MK%+,2OX+<AL#&&D%,.IvT   tRNSIJee   IDATxMZEAu_»≥<v inv√•nea6AŒæv{@ E' d I! inv√•n  CT inv√•ng  inv√•n1E(SQsi


# ==== README.md ====

# AITTC Experimental Farm Management System

## Project Overview
This project digitizes the paper-based management system of the AITTC Experimental Farm, providing a comprehensive web application for field reservations, project management, inventory tracking, and administrative workflows.

## Objectives
- Enable external clients to register and request field reservations
- Provide admin control over users, fields, projects, inventory, and documents
- Track real-time field utilization and project status
- Digitize forms F.10 (inventory), F.47 (price offers), and F.84 (service orders)
- Implement role-based access control (Admin, Supervisor, Client)

## System Architecture

### Technology Stack
- **Backend**: Node.js with Express.js
- **Database**: PostgreSQL with Prisma ORM
- **Frontend**: React with TypeScript
- **Authentication**: JWT with email verification
- **File Storage**: Local file system for PDF generation
- **Email**: Nodemailer for notifications

### Database Schema
The system uses a relational database with the following core entities:
- Users (Admin, Supervisor, Client roles)
- Entities (organizations)
- Fields (with surface area tracking)
- Projects (linked to fields and users)
- Reservations (client requests)
- ActivityTypes (categorization)
- InventoryItems (F.10 form data)
- PriceOffers (F.47 form data)
- ServiceOrders (F.84 form data)

## Installation and Setup

### Prerequisites
- Node.js 18+
- PostgreSQL 14+
- npm or yarn

### Installation Steps
1. Clone the repository
2. Install dependencies: `npm install`
3. Set up environment variables (see `.env.example`)
4. Run database migrations: `npm run db:migrate`
5. Seed initial data: `npm run db:seed`
6. Start the development server: `npm run dev`

## User Roles and Permissions

### Admin
- Full CRUD access to all entities
- Approve/reject reservations
- Assign supervisors to projects
- Manage inventory and alerts
- Generate reports and exports

### Supervisor
- View assigned projects
- Update project status and progress
- Cannot modify approvals or field allocations

### Client
- Register with email verification
- Submit field reservation requests
- View own reservations and projects
- Cannot access other users' data

## Core Features

### Field Management
- Real-time surface area tracking
- Visual utilization indicators
- Status management (Active/Inactive)
- Location and notes

### Reservation System
- Client request workflow
- Admin approval/rejection
- Automatic surface area deduction
- Supervisor assignment

### Project Tracking
- Timeline visualization
- Status updates (En cours, Finalis√©, Programme, A lancer)
- Progress notes and documentation

### Document Management
- Digital forms for F.10, F.47, F.84
- PDF generation and archiving
- Search and filtering capabilities
- Export functionality (CSV/PDF)

### Inventory Management
- Stock tracking with alerts
- Condition monitoring
- Location management
- Weekly inventory updates

## Business Rules
- Reservations cannot exceed available field surface
- Project completion releases surface area back to fields
- Fields with active projects cannot be deleted
- Inventory alerts for non-conforming items
- Form versioning for audit trails

## API Documentation
The system provides RESTful APIs for all operations with proper authentication and authorization.

## Testing
Comprehensive test suite covering:
- User authentication and authorization
- Business rule validation
- API endpoints
- User workflows
- Data integrity

## Deployment
The application can be deployed using Docker containers with proper environment configuration.

## Support
For technical support or questions, please contact the development team. 

# ==== .env ====

# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/aittc_farm_db"

# Server Configuration
PORT=3001
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here
JWT_EXPIRES_IN=7d

# Email Configuration (for verification and notifications)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASS=your-app-password
EMAIL_FROM=AITTC Farm Management <noreply@aittc.ma>

# File Upload Configuration
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Admin Default Account
ADMIN_EMAIL=admin@aittc.ma
ADMIN_PASSWORD=admin123
ADMIN_NAME=System Administrator

# Application URLs
FRONTEND_URL=http://localhost:3000
BACKEND_URL=http://localhost:3001 

# ==== env.example ====

# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/aittc_farm_db"

# Server Configuration
PORT=3001
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here
JWT_EXPIRES_IN=7d

# Email Configuration (for verification and notifications)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASS=your-app-password
EMAIL_FROM=AITTC Farm Management <noreply@aittc.ma>

# File Upload Configuration
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=10485760

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Admin Default Account
ADMIN_EMAIL=admin@aittc.ma
ADMIN_PASSWORD=admin123
ADMIN_NAME=System Administrator

# Application URLs
FRONTEND_URL=http://localhost:3000
BACKEND_URL=http://localhost:3001 

# ==== combine_code.py ====

import os

# Directories to exclude
EXCLUDE_DIRS = {
    'node_modules', 'venv', 'env', '__pycache__', '.git', '.next', 'dist', 'build', 'packages', '.turbo', '.cache'
}
# File extensions to EXCLUDE
EXCLUDE_EXTS = {
    '.json', '.pdf', '.txt'
}

def should_include_file(filename):
    return not any(filename.endswith(ext) for ext in EXCLUDE_EXTS)

def main(root_dir, output_file):
    with open(output_file, 'w', encoding='utf-8') as out:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Remove excluded directories in-place
            dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]
            for filename in filenames:
                if should_include_file(filename):
                    rel_path = os.path.relpath(os.path.join(dirpath, filename), root_dir)
                    out.write(f"\n\n# ==== {rel_path} ====\n\n")
                    with open(os.path.join(dirpath, filename), 'r', encoding='utf-8', errors='ignore') as f:
                        out.write(f.read())

if __name__ == "__main__":
    # Change '.' to your project root if needed
    main('.', 'all_code_combined.txt')

# ==== prisma/schema.prisma ====

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User management
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String
  name          String
  role          UserRole @default(CLIENT)
  entityId      String?
  isVerified    Boolean  @default(false)
  verificationToken String?
  resetToken    String?
  resetTokenExpiry DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  entity        Entity?  @relation(fields: [entityId], references: [id])
  clientReservations Reservation[] @relation("ClientReservations")
  supervisorReservations Reservation[] @relation("SupervisorReservations")
  supervisorProjects Project[] @relation("SupervisorProjects")
  clientProjects Project[] @relation("ClientProjects")
  createdPriceOffers PriceOffer[] @relation("CreatedBy")
  createdServiceOrders ServiceOrder[] @relation("CreatedBy")

  @@map("users")
}

model Entity {
  id          String   @id @default(cuid())
  name        String
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users       User[]

  @@map("entities")
}

// Field and project management
model Field {
  id              String   @id @default(cuid())
  name            String
  location        String
  totalSurfaceM2  Float
  freeSurfaceM2   Float
  status          FieldStatus @default(ACTIVE)
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  projects        Project[]
  reservations    Reservation[]

  @@map("fields")
}

model ActivityType {
  id          String   @id @default(cuid())
  label       String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  projects    Project[]

  @@map("activity_types")
}

model Project {
  id              String        @id @default(cuid())
  title           String
  fieldId         String
  clientId        String
  supervisorId    String
  activityTypeId  String?
  surfaceM2       Float
  startDate       DateTime
  endDate         DateTime?
  status          ProjectStatus @default(A_LANCER)
  progressNotes   String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  field           Field         @relation(fields: [fieldId], references: [id])
  client          User          @relation("ClientProjects", fields: [clientId], references: [id])
  supervisor      User          @relation("SupervisorProjects", fields: [supervisorId], references: [id])
  activityType    ActivityType? @relation(fields: [activityTypeId], references: [id])

  @@map("projects")
}

model Reservation {
  id                    String            @id @default(cuid())
  clientId              String
  fieldId               String
  surfaceM2Requested    Float
  startRequested        DateTime
  endRequested          DateTime
  status                ReservationStatus @default(PENDING)
  decisionDate          DateTime?
  supervisorId          String?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relations
  client                User              @relation("ClientReservations", fields: [clientId], references: [id])
  field                 Field             @relation(fields: [fieldId], references: [id])
  supervisor            User?             @relation("SupervisorReservations", fields: [supervisorId], references: [id])

  @@map("reservations")
}

// Document management (F.10, F.47, F.84)
model InventoryItem {
  id              String   @id @default(cuid())
  owner           String
  family          String
  subFamily       String?
  designation     String
  stockQty        Float
  unit            String
  condition       ItemCondition @default(OK)
  location        String
  lastChecked     DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("inventory_items")
}

model PriceOffer {
  id                String   @id @default(cuid())
  destinataire      String
  demandeur         String
  contact           String?
  address           String
  orderNumber       String?
  itemDesignation   String
  unit              String
  techDescription   String?
  quantity          Float
  dateSent          DateTime @default(now())
  status            OfferStatus @default(PENDING)
  createdById       String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  createdBy         User     @relation("CreatedBy", fields: [createdById], references: [id])

  @@map("price_offers")
}

model ServiceOrder {
  id              String   @id @default(cuid())
  objet           String
  marketNumber    String?
  bcNumber        String?
  startDate       DateTime
  clientRep       String
  supplier        String
  status          OrderStatus @default(IN_PROGRESS)
  dateNotified    DateTime @default(now())
  createdById     String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  createdBy       User     @relation("CreatedBy", fields: [createdById], references: [id])

  @@map("service_orders")
}

// Enums
enum UserRole {
  ADMIN
  SUPERVISOR
  CLIENT
}

enum FieldStatus {
  ACTIVE
  INACTIVE
}

enum ProjectStatus {
  EN_COURS
  FINALISE
  PROGRAMME
  A_LANCER
}

enum ReservationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ItemCondition {
  OK
  NON_CONFORME
  MAUVAIS
}

enum OfferStatus {
  PENDING
  SENT
  ACCEPTED
  REJECTED
}

enum OrderStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
} 

# ==== prisma/migrations/migration_lock.toml ====

# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

# ==== prisma/migrations/20250629151932_init/migration.sql ====

-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('ADMIN', 'SUPERVISOR', 'CLIENT');

-- CreateEnum
CREATE TYPE "FieldStatus" AS ENUM ('ACTIVE', 'INACTIVE');

-- CreateEnum
CREATE TYPE "ProjectStatus" AS ENUM ('EN_COURS', 'FINALISE', 'PROGRAMME', 'A_LANCER');

-- CreateEnum
CREATE TYPE "ReservationStatus" AS ENUM ('PENDING', 'APPROVED', 'REJECTED');

-- CreateEnum
CREATE TYPE "ItemCondition" AS ENUM ('OK', 'NON_CONFORME', 'MAUVAIS');

-- CreateEnum
CREATE TYPE "OfferStatus" AS ENUM ('PENDING', 'SENT', 'ACCEPTED', 'REJECTED');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('IN_PROGRESS', 'COMPLETED', 'CANCELLED');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "passwordHash" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "role" "UserRole" NOT NULL DEFAULT 'CLIENT',
    "entityId" TEXT,
    "isVerified" BOOLEAN NOT NULL DEFAULT false,
    "verificationToken" TEXT,
    "resetToken" TEXT,
    "resetTokenExpiry" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "entities" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "notes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "entities_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "fields" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "location" TEXT NOT NULL,
    "totalSurfaceM2" DOUBLE PRECISION NOT NULL,
    "freeSurfaceM2" DOUBLE PRECISION NOT NULL,
    "status" "FieldStatus" NOT NULL DEFAULT 'ACTIVE',
    "notes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "fields_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "activity_types" (
    "id" TEXT NOT NULL,
    "label" TEXT NOT NULL,
    "description" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "activity_types_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "projects" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "fieldId" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "supervisorId" TEXT NOT NULL,
    "activityTypeId" TEXT,
    "surfaceM2" DOUBLE PRECISION NOT NULL,
    "startDate" TIMESTAMP(3) NOT NULL,
    "endDate" TIMESTAMP(3),
    "status" "ProjectStatus" NOT NULL DEFAULT 'A_LANCER',
    "progressNotes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "projects_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "reservations" (
    "id" TEXT NOT NULL,
    "clientId" TEXT NOT NULL,
    "fieldId" TEXT NOT NULL,
    "surfaceM2Requested" DOUBLE PRECISION NOT NULL,
    "startRequested" TIMESTAMP(3) NOT NULL,
    "endRequested" TIMESTAMP(3) NOT NULL,
    "status" "ReservationStatus" NOT NULL DEFAULT 'PENDING',
    "decisionDate" TIMESTAMP(3),
    "supervisorId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "reservations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "inventory_items" (
    "id" TEXT NOT NULL,
    "owner" TEXT NOT NULL,
    "family" TEXT NOT NULL,
    "subFamily" TEXT,
    "designation" TEXT NOT NULL,
    "stockQty" DOUBLE PRECISION NOT NULL,
    "unit" TEXT NOT NULL,
    "condition" "ItemCondition" NOT NULL DEFAULT 'OK',
    "location" TEXT NOT NULL,
    "lastChecked" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "inventory_items_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "price_offers" (
    "id" TEXT NOT NULL,
    "destinataire" TEXT NOT NULL,
    "demandeur" TEXT NOT NULL,
    "contact" TEXT,
    "address" TEXT NOT NULL,
    "orderNumber" TEXT,
    "itemDesignation" TEXT NOT NULL,
    "unit" TEXT NOT NULL,
    "techDescription" TEXT,
    "quantity" DOUBLE PRECISION NOT NULL,
    "dateSent" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "status" "OfferStatus" NOT NULL DEFAULT 'PENDING',
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "price_offers_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "service_orders" (
    "id" TEXT NOT NULL,
    "objet" TEXT NOT NULL,
    "marketNumber" TEXT,
    "bcNumber" TEXT,
    "startDate" TIMESTAMP(3) NOT NULL,
    "clientRep" TEXT NOT NULL,
    "supplier" TEXT NOT NULL,
    "status" "OrderStatus" NOT NULL DEFAULT 'IN_PROGRESS',
    "dateNotified" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "createdById" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "service_orders_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "activity_types_label_key" ON "activity_types"("label");

-- AddForeignKey
ALTER TABLE "users" ADD CONSTRAINT "users_entityId_fkey" FOREIGN KEY ("entityId") REFERENCES "entities"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "projects" ADD CONSTRAINT "projects_fieldId_fkey" FOREIGN KEY ("fieldId") REFERENCES "fields"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "projects" ADD CONSTRAINT "projects_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "projects" ADD CONSTRAINT "projects_supervisorId_fkey" FOREIGN KEY ("supervisorId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "projects" ADD CONSTRAINT "projects_activityTypeId_fkey" FOREIGN KEY ("activityTypeId") REFERENCES "activity_types"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "reservations" ADD CONSTRAINT "reservations_clientId_fkey" FOREIGN KEY ("clientId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "reservations" ADD CONSTRAINT "reservations_fieldId_fkey" FOREIGN KEY ("fieldId") REFERENCES "fields"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "reservations" ADD CONSTRAINT "reservations_supervisorId_fkey" FOREIGN KEY ("supervisorId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "price_offers" ADD CONSTRAINT "price_offers_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "service_orders" ADD CONSTRAINT "service_orders_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


# ==== client/.env.local ====

REACT_APP_API_BASE_URL=http://localhost:3001/api


# ==== client/README.md ====

# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can‚Äôt go back!**

If you aren‚Äôt satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you‚Äôre on your own.

You don‚Äôt have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn‚Äôt feel obligated to use this feature. However we understand that this tool wouldn‚Äôt be useful if you couldn‚Äôt customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).


# ==== client/.gitignore ====

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


# ==== client/public/favicon.ico ====

           F          )         9  5  @@       n  PNG

   
IHDR         (-S   PLTE""""""""""""""""""2PX=r)7;*:>H-BGE8do5Xb6[eKK1MU9gs3S\I:gt'03@{VTA}V@y6\fH-CIIE+;@7_i7_jFJKH-BHa,@FCL&.0WNI$)+BJR?v>s>uS=qPPP,?D4U^%+-MK%+,2OX+<AL#&&D%,.IvT   tRNSIJee   IDATxMZEAŸ≥	%RTThG,=mfmnfA$>!gHgEﬂè‹µ}	›ªkdJo3L"JQ$ƒºff,5i9ÃüH/mBww;D
+&WDo@ ¥RIBom.€≥    IENDB`PNG

   
IHDR         ◊©  ePLTE""""""""""""""""""""""""2RZNJ3R[J)59Y0KS4W`QL%+-0JR)6::gtC"##?vU?w<n{&-/Y=q:iuBA}A{B/IPP=qK_L$();lzRaIZ3U^1MU3T]ZIXF-BGP6[e,@E5ZdO-BHX+=AW,@FWQ?vW+<A@y"#$\4Wa\S$(*.EL^V6]h#$%G#&';jwV-CILZ^>uS/HNM_\M8doDD>t+=B[,>C>t<o}@y0LS.EKT$'(%,.A~WC%+,\C!   tRNSÓêàG  OIDATxlBQu_»≥<vea6AŒæv{@ E' d I!  CTg  1E(SQsi
ƒèZV )g!ht-i}<?lBZaƒ¥4{D‚åª_e8y«Å3)?f;8.t=;	:52fKZlÿö9.#AqV`=$?_qM.J$
?^q€è.},s_Ttt‘æ 1#/(-[``Zd5?ebZﬁài.qŒÑ+1}¬å5  dG    IENDB`PNG

   
IHDR           D  APLTE   """""""""""""""""""""""""""2RZV_U=r$()'25]C0LS<o}XX0JQ=p~D<n{VE8do_EFH9dp_HIF6[e``L/GM_U'02P/IPPX&/1;ly3R[`GT\a1OW"##QaR=q`.EL+=AT-CIK#&'C^I&.04U^^@yZ$(*[^,?DR"#$1NV1MTD>u;kxGR/HN&-/@y>s>t@z]P$'(D]<n|0JRU\   	tRNS %'(~  IDATxC1F_›øMm€∂4m{n	A$$b HeTWhh:PtZ
Q0@.``4-V`Z&A#bk>.''`C$F	(x"6XcTL@I;d d-|P,»î9Rf3FVmMX@Y7N= ™u
}÷¨+eaiq 76=h
Zl} ±[FI9Ak939Œ°qB~bU_^ [w{zvz(((fqGkYf~:*4Q\O><◊ìWZ|ﬁã7jTn`$H+GO*xX*|^d    IENDB`PNG

   
IHDR   @   @     :PLTE   """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""%+-@yW`^SC,>C*8<XaaM+<AaX#%%TL=q>uK`A}L8do=r%+,@y^S)59=qPU"#$P\0JQQ"##U#&&_>t>s`_5Yc1OW5Zd1NV+=B1MU+;@/GM\*;?3S\)8<2RZ_+=A],@F,@E&-/0KS7alO9dp8amB~EPN'023T]]?x3U^C6\gU&.0D7_iRHIM$(*?vZX-AG#$%[8co[WC'25?v8bn%*+LN2PX)7;=p~(58^P4WaQT0JRQTI6]hRT0LSF9eqEE9gsFC#&'\`&/16\fBA{R](47%,.*:>*9=9fr:gt7^iU?wZX^QH)6:V'034U^E.EL.FMK@zS   tRNS *	+‘ê,=V  IDATxÀµC! ÔäñC|^yR]MO]0N2"(0V(Y%PDT-~(m!KY~If{a3Op&–§ x#j⁄∂mmc)]m)∆ßgfhk“†gg«ô+XuiyV◊™k\[:,6jƒ≤
;";XfS8=o;(”•Bke\7p+mN<QOygttoVs&_aV~?*8Q ;8,f1x◊ß*Aa##nPi+C,_Nb√∏ HB*“¶ L( ^<√ÅL6pJP%"R,9e3eRa1(
q8ŸémKÀ±m∆∂myi!Œ™Yu_?i+A|{?_En).JD<
Z\TsR*(	JuX/
4J95DE4k4&iV4vsf:g,BC$ÓÅá@I_?<!^”ΩB%LwFD1(FH%0ÿÑ(0'N.0u@YPWIaNK?”µ=ev/c0c02:06R-uƒ≠\QÃ∂‰¥º6R#
F6r’ÅumIi~ √èsP" 
eiyPÚíß°,S]UV÷îZoxzSnm{⁄∫waŸÑ≈ª(mg/[bq&’Ø$z»äH>aKT1/1O0.hÕáYA
->€ãX’¢}ﬂ®;NvŒ∏1 O@&v/_\\.+0;!f% JYO¬é'/]_;'"&Nn	aQ^ cxA    IENDB`

# ==== client/public/index.html ====

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>


# ==== client/public/logo512.png ====

PNG

   
IHDR         √¶$   xPLTE   aaa^aa`baaaa`aacaaaaaa_baaaaaaa`aaaaaaa9   'tRNS 	”™L+Uy
e:3"Àª@o&_jDtZYMu  $IDATx                  ]{]N !(" mO;Zo	dG»ûMŒÑ1c1c2_65 7^F Y]EJW*A”´};)B∆ëO]"qt2e"/SeZdD#[\>h¬ºl1l%7K<DOÏáñZdy;|Õ´Bzp[~bO[<DGmTG)<N9]
70h|K	#-k»±# 8S7xA-6QÕäQ0kNNj`Z[}Y%`⁄ñty»≤‹É9g+lfN=%l	[Rc$i»ä=	96y%lN}(jvde;B <a",Z
{z—û.$BG$3H^N€πR“æg.iË±àm3x~ ìm%4oIÃû
A/¬¢:_'q`MP9gKRE
}S9c#7J|__zco‹ä`P)!G;-q(;ÔüÇ	d} eFT!ivB!v9c3H,m*9S&{pM5KDivx)gPk(.&h
I¬´jb/\∆πP¬æjhW0GZNt\hcœáXDB,1P_UTEw|Tz

Tt›äaD iv÷ø;@AA{2d>UTdP≈£EVV
^x2sa|73s$19eky@9Cc78WJiB,}=6pi`_ TtT0‘ò›¨K#om^nD∆õx#f+⁄´dBŒπ:Zij)zgzU#z;9r\—¢/Onk[[z‘óYAD5
GFÀ†vL1]"-ZF»∑ii.*Hk{Mk*WOVZB#mRqqEZz/.#}%0:A+cHb1^y':F3UAfDNJ\/-(<'66vIBVi7ﬂ¢70ÿÅB*~OYL&6U@~NAFTZ`ﬁÑu~Efx6Õâ3}LaY≈∏qÁûâq.w[fX]oGshh`] X^[lm,
Y¬î3C!NfZ\‚áÇWAy)8Pd∆û !t&clyw~> 5>@xos<d H i , ~N&|`7, ,N;{w
%vÃæcc~7L&IeBHRIUcR>p9;Y
E!v*VjY	fSm'vS2Xsdh{JÀô”™-d49pGRR2+]Bs# Th_@ZepG;^#Pwr7“Ωx(3D7{
GP3[BzdPH]:o\qLj{7Zfdf#tsknpe¬Ø~ Y:AaoG`Vﬂü
{pv0=ZWKwWÒî®åNXo!hZ /MK.E6cy5 4i%i%XbjLﬂª(y{eOqM ^AJWx[",GU
cd;ƒàY+rt^oOB
P]atRfq=x4hV2"'rlYÕµ !h).{}ƒ∑ah::=h8|UZ{
 ]u84C4 ir[m"ÁÖ∏Y JT OŸ©$i[*S<azÀ±x/w_}qs]gx`-UhZ6VXYuk7B=:v> ¬ùEdÊûûS+!
D÷µOd≈ãfF›±Õ°.
+ÎÇö“ÉG~\]04BU`?c=5_(cOC'
X|,'#oX%3{j[]:?e?z~uBt*p‹´<ﬂ≤k sXc|ÿÉ‘ã=÷Ä“á}m71~;)W”é”Ö+o7ﬁÑB/:_wÁ≠ö:Q«á~
PI+/Nÿ∂7~fh‘éZ9vqkVMau#zFq 5"GC’¢^=(”£^yp]Õ™xWGP	BfDQCn|—Æ ’∫)29/[[XPx;P@dQo
~7M(%Y,PB÷Ñ~$9HQ
d2G'M$ 1‘êDIijFZc:#J^\&eZ~H#z[Q9F0PWÿûAze&LhDI,jLp1{km%H((2o
\)"~OqP&$tq3D_&Ó¥ÖPOVh`]ÂÅ†D8_bwe(rXO"[b#SBCh|l «ÖT%=>÷†Yf)k;DGB&PD[#Si*X/VcGy1PDne'&>L(sBu`[" t2+"uY%
%"u5*k„•Ä\q=Œ≠U/…ölO–£vdY.#K \^rsJ[<.|x+K <+4JdIB|iu:9XJ√∫J"–Åe–≤	3XaDB6UgL
Hh@"\uZ/fK÷èXjÿ™AQSccCS;#V¬§:s
fE1‡πù&qz‹¨ 4LoJ5C^$*qo?1+}>j @¬ë//u√≥m Ø◊Å_FNGcRR)w:e1¬ôpbUjX|?p2+I⁄®Ja$	02ig%%cl[0
Q
m\.y!8VF{Y;E.
!WŒΩ%18h)Id+f!ClB]kdUo.1#X6…∑UN07TFJ!{K pp)’ïS3_8|PƒùZ/HA\~i;(E”±

862ÚÅáâ:aQ8k!&B}MVkz>q;dh"I>R	SAg|6—¶q@@S<sh8
3T¬£3[s]./c3!	ahl'Wm6ZZ›ÄiB6p ë%c {|S#Q.9C-L]y-»ºﬂì :%zoiN>ky/ËñÆE(ut OCMz %{	{ŒíJ'pr∆¥{^R"÷æ*IpidTN8S kRg!5HSaHX.Vm\Q"SLv'f _L5EZS|Jd3; JJ)?”≤ÕÅ a+jÕß#@	lŸí/„òÄGC^%_6<9V
PEMŒål?,1~rb9 x!-:q_ 
Gj5A7ku (Hj5Z^&d&diH{sovb@kGœ° Z4)ZB≈¥jD;Q;hCIEzLU43q0GYcr –à
%√∫z'M	gahC`C=oxwD:!–Çy&n !1/05jj; lpÀß}lc·ø∑NV~@CV6tLmI"V
QESw&Hf>;sz5}Qd
“âez»ä,H)WlhM9S5<j~T-;⁄ñ6Ac4lT[34%)vPh-ZXsy[y 1!pVC{
(#4&<w2AE>E|BcN / Uo*Wq9
<?oHP
4
#@MbÓß≠:W*k.lM.E [RgÍöØ‘Ø: :›ïFuqkv&|Dc2!$Jv ;4 1rvnn4X-wEc
Z9}SrP jÀ∫zÂã™"<4d";ÁíÄ
7…∑l$}!9YQZ„ÇÄWfhHEw–≠b∆õDq'D!C3 }U<uL3-d,vQK8i
4mT6J`
8:'e$GX? O@4(t#R 6?!(7⁄πF
ub0i|!d$O:Gn ÏØ´^\$|e6[eI;`Gv\YT+
Ã®_]%]A`eMFW
\Õ¶!)_7P`@ddH*61T`@’†s&e@DMA,_8+1[(?5H0YQ9O?€´Z^I.~:y%H%]geÕæBu;C
D]UkIw=BCLXk3SgtsK73@EUg(PY<"k8#z&hspdu}i ]d8“è(=V61I{ ∑Ÿå–´nh2
q^ Ôáê`( _
.hJso5;pBn\}(}0\R~n|R
j5AUcÈóæRN3\\`=,jjBa7ppX,/kUr=3\I%$hk@u)PWi9f6`wfN\%%Of
UÀ≥4U4TL{"4L
.}D5HOR9veD=e*AMvA^@XvQF1—æ5_#de=(mFn9C
:5‘≤g{«†$"%:$÷µ8]6$7MM∆†√•-j/@{(w%[_
I=T‘∑>8~]4JFs83GIlTx…ó
?as-LobIR0dSu\Ni&eyW4+ J6RXCi_.–´ƒ∞V]DT+‘éhTcE+]xUÓ∫ÉÂ®ù^JCL3T$WX√ÜJ5x&
~B%M(Sb=l	GD≈§T2T^06zrfRo9*a-h,W?F*T&T`CQ€º+We_uP Ü*Sl
/_`z_jDu*7l&7}Ó°∫Cv8jp‘®0P}xqP]! <t=%2qtK9G=Kq?7R A=N[9i@wIZ#R⁄ï`Ep1	J.l,AgsEJ=el@"_$GDxFK$“¥O ^sIWo;ÿërC-ﬁ™JL	WNe
r;[j}V ⁄á+”ª	x7ÿ´ksdÎ¥†ﬁé#}9H#:√û-G"4gGAC-'Z!wA:<)tHjq3<7?!:7H;q(XF	2!*!)#RSr?B aU&83NnD! N3p8}V&4~N`Dsx–≤	—≤155vSaI~u_ 0=gehxM3{I,_a.uq`h{n3ks?Dg7=|Dt.>E_b'4d?›ïyKb_pÿ±unE”•78t7
ÍüΩ -O%[wË°ÄM}{JxeK’ú9~dnW[cŒñUJi€ü+Àπ[~%?]u9yxTJ«¥}ro V`uU	OÔíß>~	C4U8?iUyRh RS+E5ŒÉi’¥.!pX`FxcWgv}–å\u:_0#
X!gsv,_iK{J]D:(∆Ω7a@Cwuo Dcq;lto@wO-\uY}V_?V‹≥,.SW
zz])Z≈™s
wYÎ∫£U<pO.v"Rh4=AyC◊Ñ|46›é$%6;D/Àìk-;
`St‹â#v*OsÕóZjC’ò GDc\ F%—ä&G6pAJ,.zDJ:–îNu!@7y{“îbÀ≤	hR›º%
1\ÀÖÿî=cEr+/JS=UﬁüZny`ks@mCs:≈Ø@&,¬±, 
hE6Vr»èi^RU|wfcŒÖ@sU*+=P~Èêê
U>TsjVE|ﬂædRwOvG  `%)bUJHw;%
9zInS(iN!
Hœ¢:1zcQNP(s)@GX( KD≈Ç3‹Ü—ÉE"MH
]*—äT{Y9<JgjWerUC|u”° 0+HZF0EyClZWd,x=dza›õuGOeJ0jE.1%{;◊§^iQ◊Äm÷É4V  XL) r2 O9 (]C∆ä: *@D}no}|“®2$ U-1# [a  `@N7≈û('#t8@>K‘Ñ6dd@EŸªm ('@+“¶n &rI3C%MlM55^g;g) -i%^$
yWyq}√î °l·ª§∆ÄP>8!)V‘¶'1fRnYJt,+*%3ƒΩ>JUS]Q!Y$Zj/sI^2Ã¶8<Via ;"YZ}hDK($%.V ÖcI*9i"MJ*huuE#)peOU@b"_%,4%hl~e7p	y"l[a8"_i%fE@`P:2rj
VVd\cpAlA”©L/wH_÷ÄspSdQB\Òòø¨1,.	+Mƒ±utWg+bQ6fNk2.X-G:Pv1x{n `w√∫(7(7D b}8*R≈∏?Go$!¬ª=v.bQ
lCc-Ÿâ!—ô∆ä>d)!+g	64
vRt(hv'9BX,~tÿÉ/%YbXohw0IN!_ZTo[IAOCj6J
D-9D	7~%7gtkr>!,G5oeÀè‘É8Rr6%:	d|%{Fg<)Cl>SvF%zdC-k inYN[0|g(fY<`in13:’ô d;~~p4%XiÚò¶ñ:PY*%KR!VfHqRRc`
M0uv1~<J!)PB	9dL&bt*&≈§C@q*xLUi+O.1x4/#L
4+"L#^◊â%0rx>yd'frN$e4P0;4pKy—ëÊ∂ºz[:0J0YÃÑ#Áµâ 7qWd5&}8W…ÅnMlwI4uÕªuo;7N<6ÀãF?=≈©yWG0h'/nubOIwOG>b4^-AjqnsYeƒüK{pH     k_                  n]    IENDB`

# ==== client/public/logo192.png ====

PNG

   
IHDR         e5   PLTE   daaaaaaaaaaaaaaaaaa`aaaaaaa`aaaaaaaaaaafacehH∆î   'tRNS #,_ELn?X4Qgyt:≈á!  IDATx[r0.l.;>i?_-,)L'ﬁ´ooooo*x-F?&?BY>MOq8r1O' <
xh>[q@L) ›ë◊º"7$›å/Ik*Twœ¢ OVB8O_YI. e05SH
|‹Æ/e8=vbu\5}7rl.h’µOO p'8?i3	O-»ó„îõ6 
CS 3uqHc6I)(kLV #,<—Ñ◊ütpz”û!YQyZC:«ía	xD≈ª|\MQ46b.O9QXwt3~0ÕåÃ•@Kd[Trk ≥@OX6$J,5F#0_oIyS*>mﬂêK9%m9W÷åVJuXCcp+"≈¶ÚñÇ™>)>x!"#s3d'4{HnfP	#8Cb "\@À¥FPMulv& 2·∑Ωn~P#gLÀöK7CIOÕ≠--I)@`'KOY ÿâ2r?C
C(87M|68y–≠D*U:R‹ä7GW.mT#t	;[œÇ<)WS3?kS&1)[xuPG`<d:!k-?ZR~4
H/;u[7Ur;]$oqBLgzXÂºµ…∞1TÃê@Wpk
}1 &mU$BJA:B13
Vy\i<vL∆©N.=}:2g:32t4Nv@6|*>EÍì¨f2oR	$swkq{=ﬁñFÿõkudnPPuQA	N}Lry$/"AZt; }PQfXH»ºB8’∑~>% N]nwMQw9wbPc[/'`œÅG8÷≠mw4@);^^/9UZz€èz^c ?[Í•¶<<KYiPh0lM&Y@T &(k_W{6"
Q6=eW0.8 UaqÃìz.hqyQ%W[ (kXtgWgi4PW@-aY&
*w>C^anB8jD+)yPÏ©®f{rtAsL{w:*nu-8wY*:+Cn	>ÍÅò<›¥x//a/fz}gLIsmX		Ra ytNÎö£TzCIxM]24K7#'
nPh$<C*4o[HP“úp%`:Õèa@9"Akp_VTh~,7i1TGF)-2{:n<U9ctMSd06&TQ0VB 3GDU-'CTm—ä
?k>v7m>F_’∑iiD5fXO
hW~z^jycEU '~S:4z
E=[N15GP2_?FÍèîn›ª0bQ}*br3Esy)/N|OÀ≤qSjnHu<_œºQ%ÿÇ_\$e6o3C Ç-Í°çPxBU|Rls^l(‘ùU:jmo_
0ﬁû4kD≈ßAuMj`PZL= ss\wBhNcAkg;b⁄¥Hu{T[$ =wSp=n|X0l
S)De
d[8Bhn5+&{nÎ†Ñ|-)(6!`ŒôVd[r7VsX0=$FE	53(]sA*fB{JLY|S^LT}	o`%=a‹™E_*=Bv-!H3]K√û0S@0xLDaL:B@–π;⁄ÄY ›≠?)1@rS"cZYHQ(Ar^W (pmFKzi j--
x–õ\8<C#~8G	ydS?{Áòå}5J8{0BÎ†ÄZt]z1?ThF$s}cﬁ´Vq)yW:dut%"	kEsMVdtH \*zLg1)	ZF[	%—ß,6y]hxWRWsD mt ( ~yEC-<`Nm*f xJ[√±/};@ ÷ØlO(j7L* -tg≈Øt;mEK∆íXiDsm-YŒùqmm L^H<2Hvaa)/f&U|:gst=/Q)+i a
Zev VYsH8MYxMv]~5H(x	
I€Ö3Y/xP}tVZ	Rk”Æ—∞1ose,n-LLCDn¬∂(Ji,4÷ònf5 
(^	k_`rEHZÙÅóÅz!f'*Z‹ÄGr]PSÎõö.…∞bF3jÿ™HL^}‚Ñå>+t
0d}xndZ$;PHP*Œá>M.dV6h	
8'JA+	CwFMLOw	>U-H#eA
 (#:y5Tg<j/+v2l@ySqz-$Py3Qmu!EKn>ƒáoU.T\|R;*D>M,h1G!tVY!'tASgC!Y’∞C5RÂÅØ 8E)&~Dr …¶&ËÜ£5+X}=U<fP~aQ.œÄ"…ù::{b_)]’¶\(|";Dt2*y]KR^*4dzÿãA|pjr√ºc»ì#;kH *x^Non%A/nO>QYs"!$MTx%ABf8d_	z7[ƒøBQQ3.#≈Ü
$deuŸÆ{^L=Z>Uy"Z
%$`L>]~;ﬂ¨9ﬁÜToq~gIV9I67ek|[:w0‘ñ*G!xF/L_.Ô´∞2`u0Un8JGmUh>D>NL›∑ju<#⁄ûh;H$Èé¢hz)?d;<YLxÀïÓ•ä4:n+r}EjoUctL*h^q 9@gU:@IKS÷Æﬁ¶kE}	-h@?9%7iL}K[x6P$nF{C/Œá6-3I=O@\3K…°…ú<aEF-vh6maDiGz2 ..pU
 m3=TZp0}g|A
i;MV[*Y4SP
]U*tO8x7A»≥FSE'PhDnJ8ZXPEjdfH:(2nU_h^$R2]’∑U(b*e 3›¶»∏:*bSDKTp7:7P/Ew‹éGFF^@F> R?—ÅAin?u A~st`R
aKI;V<9l
uK <j%^#hÔ•∫[JRBI"w{BrTuaw9_AGN{/Euy⁄ØtDpMg:R~;rC}9+ƒ´÷±CQ.q[ÏüÇB”ãM(@Xan!Œö:
u&»®sÎ¨ô@+GXpQ~ytXg5S&$kq"==dN^u>.Bc[8”òeS*;4>H'jS¬Ç◊ô#!\C‚£å
 ’∑‹™^7;s>√ó-b&'-mby8/
-4x<u2jBŒöqLÃßK%ÀëvB«£Z<	w€åx|8dKH}‹Ω\i*$…©]R
B80=÷ë)Cz@G *,<H]ewG
 H=R0\8\Ic,~mP2jiB}$W`i ΩÍåØ~)qm_c*x1j,]3~ †\R?vpQBI
w(3?}NS¬ì<)OySk	2$    IENDB`

# ==== client/src/index.tsx ====

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


# ==== client/src/App.tsx ====

import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import { CssBaseline, Container, Box, CircularProgress, Typography } from '@mui/material';
import { AuthProvider, useAuth } from './context/AuthContext';
import Login from './pages/Login';
import NavBar from './components/NavBar';
import Users from './pages/Users';
import Fields from './pages/Fields';
import Dashboard from './pages/Dashboard';
import Projects from './pages/Projects';
import Inventory from './pages/Inventory';
import Clients from './pages/Clients';
import Reservations from './pages/Reservations';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#dc004e',
      light: '#ff5983',
      dark: '#9a0036',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontWeight: 700,
    },
    h2: {
      fontWeight: 600,
    },
    h3: {
      fontWeight: 600,
    },
    h4: {
      fontWeight: 600,
    },
    h5: {
      fontWeight: 600,
    },
    h6: {
      fontWeight: 600,
    },
  },
  shape: {
    borderRadius: 12,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: 8,
          fontWeight: 600,
          padding: '8px 24px',
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          boxShadow: '0 4px 20px rgba(0,0,0,0.1)',
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 16,
        },
      },
    },
  },
});

const AppRoutes = () => {
  const { user, loading } = useAuth();

  if (loading) {
    return (
      <Box
        sx={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          minHeight: '100vh',
          background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
          gap: 3,
        }}
      >
        <CircularProgress 
          size={60} 
          thickness={4}
          sx={{ 
            color: '#fff',
            '& .MuiCircularProgress-circle': {
              strokeLinecap: 'round',
            }
          }} 
        />
        <Typography 
          variant="h6" 
          sx={{ 
            color: '#fff', 
            fontWeight: 500,
            textAlign: 'center',
            textShadow: '0 2px 4px rgba(0,0,0,0.3)',
          }}
        >
          Chargement en cours...
        </Typography>
      </Box>
    );
  }

  return (
    <>
      {user && <NavBar />}
      <Container 
        sx={{ 
          mt: 4, 
          mb: 4,
          px: { xs: 2, sm: 3, md: 4 },
          maxWidth: '1400px',
        }}
      >
        <Routes>
          <Route path="/login" element={user ? <Navigate to="/dashboard" /> : <Login />} />
          <Route path="/dashboard" element={user ? <Dashboard /> : <Navigate to="/login" />} />
          <Route path="/users" element={user ? <Users /> : <Navigate to="/login" />} />
          <Route path="/fields" element={user ? <Fields /> : <Navigate to="/login" />} />
          <Route path="/projects" element={user ? <Projects /> : <Navigate to="/login" />} />
          <Route path="/inventory" element={user ? <Inventory /> : <Navigate to="/login" />} />
          <Route path="/clients" element={user ? <Clients /> : <Navigate to="/login" />} />
          <Route path="/reservations" element={user ? <Reservations /> : <Navigate to="/login" />} />
          <Route path="/" element={<Navigate to={user ? "/dashboard" : "/login"} />} />
        </Routes>
      </Container>
    </>
  );
};

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <AuthProvider>
        <Router>
          <AppRoutes />
        </Router>
      </AuthProvider>
    </ThemeProvider>
  );
}

export default App;


# ==== client/src/App.test.tsx ====

import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


# ==== client/src/App.css ====

body, html, #root {
  margin: 0;
  padding: 0;
  min-height: 100vh;
  width: 100vw;
  background: #f4f6fa;
  font-family: 'Inter', 'Roboto', 'Segoe UI', Arial, sans-serif;
  color: #232946;
}

* {
  box-sizing: border-box;
}

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


# ==== client/src/index.css ====

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


# ==== client/src/setupTests.ts ====

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


# ==== client/src/reportWebVitals.ts ====

import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


# ==== client/src/react-app-env.d.ts ====

/// <reference types="react-scripts" />


# ==== client/src/logo.svg ====

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

# ==== client/src/context/AuthContext.tsx ====

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import api from '../services/api';

interface User {
  id: string;
  name: string;
  email: string;
  role: 'ADMIN' | 'SUPERVISOR' | 'CLIENT';
  isVerified: boolean;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  register: (data: RegisterData) => Promise<void>;
  token: string | null;
}

interface RegisterData {
  name: string;
  email: string;
  password: string;
  entityId?: string;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(localStorage.getItem('token'));
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchProfile = async () => {
      if (token) {
        try {
          const res = await api.get('/auth/profile');
          setUser(res.data);
        } catch (err) {
          setUser(null);
          setToken(null);
          localStorage.removeItem('token');
        }
      }
      setLoading(false);
    };
    fetchProfile();
  }, [token]);

  const login = async (email: string, password: string) => {
    setLoading(true);
    try {
      const res = await api.post('/auth/login', { email, password });
      setToken(res.data.token);
      localStorage.setItem('token', res.data.token);
      const profile = await api.get('/auth/profile');
      setUser(profile.data);
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
  };

  const register = async (data: RegisterData) => {
    setLoading(true);
    try {
      await api.post('/auth/register', data);
    } finally {
      setLoading(false);
    }
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout, register, token }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}; 

# ==== client/src/components/NavBar.tsx ====

import React from 'react';
import { AppBar, Toolbar, Typography, Button, Box, Avatar, Chip } from '@mui/material';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import DashboardIcon from '@mui/icons-material/Dashboard';
import PeopleIcon from '@mui/icons-material/People';
import AgricultureIcon from '@mui/icons-material/Agriculture';
import AssignmentIcon from '@mui/icons-material/Assignment';
import EventIcon from '@mui/icons-material/Event';
import InventoryIcon from '@mui/icons-material/Inventory';
import LogoutIcon from '@mui/icons-material/Logout';

const NavBar: React.FC = () => {
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  if (!user) return null;

  const getRoleColor = (role: string) => {
    switch (role) {
      case 'ADMIN': return '#d32f2f';
      case 'SUPERVISOR': return '#1976d2';
      case 'CLIENT': return '#388e3c';
      default: return '#757575';
    }
  };

  const getRoleLabel = (role: string) => {
    switch (role) {
      case 'ADMIN': return 'Administrateur';
      case 'SUPERVISOR': return 'Superviseur';
      case 'CLIENT': return 'Client';
      default: return role;
    }
  };

  return (
    <AppBar 
      position="static" 
      sx={{
        background: 'linear-gradient(135deg, #1976d2 0%, #1565c0 100%)',
        boxShadow: '0 4px 20px rgba(0,0,0,0.15)',
        borderBottom: '1px solid rgba(255,255,255,0.1)',
      }}
    >
      <Toolbar sx={{ px: { xs: 2, md: 4 }, py: 1 }}>
        <Typography 
          variant="h6" 
          sx={{ 
            flexGrow: 1, 
            fontWeight: 700,
            fontSize: { xs: '1.1rem', md: '1.3rem' },
            textShadow: '0 2px 4px rgba(0,0,0,0.3)',
          }}
        >
          Gestion Ferme AITTC
        </Typography>
        
        <Box sx={{ display: 'flex', gap: 1, alignItems: 'center', flexWrap: 'wrap' }}>
          <Button 
            color="inherit" 
            component={Link} 
            to="/dashboard"
            startIcon={<DashboardIcon />}
            sx={{ 
              fontWeight: 600,
              '&:hover': {
                background: 'rgba(255,255,255,0.1)',
                transform: 'translateY(-1px)',
              },
              transition: 'all 0.2s ease',
            }}
          >
            Tableau de bord
          </Button>
          
          {user.role === 'ADMIN' && (
            <Button 
              color="inherit" 
              component={Link} 
              to="/users"
              startIcon={<PeopleIcon />}
              sx={{ 
                fontWeight: 600,
                '&:hover': {
                  background: 'rgba(255,255,255,0.1)',
                  transform: 'translateY(-1px)',
                },
                transition: 'all 0.2s ease',
              }}
            >
              Utilisateurs
            </Button>
          )}
          
          <Button 
            color="inherit" 
            component={Link} 
            to="/fields"
            startIcon={<AgricultureIcon />}
            sx={{ 
              fontWeight: 600,
              '&:hover': {
                background: 'rgba(255,255,255,0.1)',
                transform: 'translateY(-1px)',
              },
              transition: 'all 0.2s ease',
            }}
          >
            Champs
          </Button>
          
          <Button 
            color="inherit" 
            component={Link} 
            to="/projects"
            startIcon={<AssignmentIcon />}
            sx={{ 
              fontWeight: 600,
              '&:hover': {
                background: 'rgba(255,255,255,0.1)',
                transform: 'translateY(-1px)',
              },
              transition: 'all 0.2s ease',
            }}
          >
            Projets
          </Button>
          
          <Button 
            color="inherit" 
            component={Link} 
            to="/reservations"
            startIcon={<EventIcon />}
            sx={{ 
              fontWeight: 600,
              '&:hover': {
                background: 'rgba(255,255,255,0.1)',
                transform: 'translateY(-1px)',
              },
              transition: 'all 0.2s ease',
            }}
          >
            R√©servations
          </Button>
          
          {(user.role === 'ADMIN' || user.role === 'SUPERVISOR') && (
            <Button 
              color="inherit" 
              component={Link} 
              to="/inventory"
              startIcon={<InventoryIcon />}
              sx={{ 
                fontWeight: 600,
                '&:hover': {
                  background: 'rgba(255,255,255,0.1)',
                  transform: 'translateY(-1px)',
                },
                transition: 'all 0.2s ease',
              }}
            >
              Inventaire
            </Button>
          )}
        </Box>
        
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, ml: 3 }}>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Avatar 
              sx={{ 
                width: 32, 
                height: 32, 
                bgcolor: getRoleColor(user.role),
                fontSize: '0.9rem',
                fontWeight: 600,
              }}
            >
              {user.name.charAt(0).toUpperCase()}
            </Avatar>
            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
              <Typography 
                variant="body2" 
                sx={{ 
                  fontWeight: 600, 
                  color: '#fff',
                  fontSize: '0.85rem',
                }}
              >
                {user.name}
              </Typography>
              <Chip 
                label={getRoleLabel(user.role)} 
                size="small" 
                sx={{ 
                  height: 20, 
                  fontSize: '0.7rem',
                  fontWeight: 600,
                  bgcolor: getRoleColor(user.role),
                  color: '#fff',
                  '& .MuiChip-label': {
                    px: 1,
                  },
                }} 
              />
            </Box>
          </Box>
          
          <Button 
            color="inherit" 
            onClick={handleLogout}
            startIcon={<LogoutIcon />}
            sx={{ 
              fontWeight: 600,
              border: '1px solid rgba(255,255,255,0.3)',
              borderRadius: 2,
              px: 2,
              '&:hover': {
                background: 'rgba(255,255,255,0.15)',
                borderColor: 'rgba(255,255,255,0.5)',
                transform: 'translateY(-1px)',
              },
              transition: 'all 0.2s ease',
            }}
          >
            D√©connexion
          </Button>
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default NavBar; 

# ==== client/src/pages/Projects.tsx ====

import React, { useEffect, useState } from 'react';
import { DataGrid, GridColDef, GridActionsCellItem } from '@mui/x-data-grid';
import { Paper, Typography, CircularProgress, Box, Avatar, Chip } from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import AssignmentIcon from '@mui/icons-material/Assignment';
import api from '../services/api';
import { useAuth } from '../context/AuthContext';

interface Project {
  id: string;
  title: string;
  field: { name: string };
  client: { name: string };
  supervisor: { name: string };
  status: string;
}

const getStatusColor = (status: string) => {
  switch (status?.toLowerCase()) {
    case 'active':
    case 'actif':
      return '#388e3c';
    case 'completed':
    case 'termin√©':
      return '#1976d2';
    case 'pending':
    case 'en attente':
      return '#f57c00';
    case 'cancelled':
    case 'annul√©':
      return '#d32f2f';
    default:
      return '#757575';
  }
};

const getStatusLabel = (status: string) => {
  switch (status?.toLowerCase()) {
    case 'active':
      return 'Actif';
    case 'completed':
      return 'Termin√©';
    case 'pending':
      return 'En attente';
    case 'cancelled':
      return 'Annul√©';
    default:
      return status || 'Inconnu';
  }
};

const Projects: React.FC = () => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [loading, setLoading] = useState(true);
  const { user } = useAuth();

  useEffect(() => {
    const fetchProjects = async () => {
      try {
        const res = await api.get('/projects');
        setProjects(res.data.projects || res.data);
      } catch (err) {
        setProjects([]);
      } finally {
        setLoading(false);
      }
    };
    fetchProjects();
  }, []);

  const handleEdit = (id: string) => {
    alert('Modifier le projet ' + id);
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('√ätes-vous s√ªr de vouloir supprimer ce projet ?')) {
      try {
        await api.delete(`/projects/${id}`);
        setProjects(projects.filter(p => p.id !== id));
      } catch (err) {
        alert('√âchec de la suppression du projet');
      }
    }
  };

  const columns: GridColDef[] = [
    { 
      field: 'title', 
      headerName: 'Titre', 
      flex: 1,
      renderCell: (params) => (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Avatar 
            sx={{ 
              width: 32, 
              height: 32, 
              bgcolor: 'primary.main',
              fontSize: '0.9rem',
              fontWeight: 600,
            }}
          >
            <AssignmentIcon sx={{ fontSize: 16 }} />
          </Avatar>
          <Typography variant="body2" sx={{ fontWeight: 500 }}>
            {params.value}
          </Typography>
        </Box>
      )
    },
    { 
      field: 'field', 
      headerName: 'Champ', 
      flex: 1, 
      valueGetter: (params: any) => params.row?.field?.name || 'Non assign√©' 
    },
    { 
      field: 'client', 
      headerName: 'Client/Entit√©', 
      flex: 1, 
      valueGetter: (params: any) => {
        const clientName = params.row?.client?.name || 'Inconnu';
        const entityName = params.row?.client?.entity?.name;
        return entityName ? `${clientName} (${entityName})` : clientName;
      } 
    },
    { 
      field: 'supervisor', 
      headerName: 'Superviseur', 
      flex: 1, 
      valueGetter: (params: any) => params.row?.supervisor?.name || 'Non assign√©' 
    },
    { 
      field: 'activityType', 
      headerName: 'Type d\'Activit√©', 
      flex: 1, 
      valueGetter: (params: any) => params.row?.activityType?.label || 'Non d√©fini' 
    },
    { 
      field: 'status', 
      headerName: 'Statut', 
      flex: 1,
      renderCell: (params) => (
        <Chip 
          label={getStatusLabel(params.value)} 
          size="small" 
          sx={{ 
            bgcolor: getStatusColor(params.value),
            color: '#fff',
            fontWeight: 600,
            fontSize: '0.75rem',
          }} 
        />
      )
    },
    {
      field: 'actions',
      type: 'actions',
      headerName: 'Actions',
      getActions: (params) => {
        if (user?.role === 'ADMIN') {
          return [
            <GridActionsCellItem 
              icon={<EditIcon />} 
              label="Modifier" 
              onClick={() => handleEdit(params.id as string)} 
            />, 
            <GridActionsCellItem 
              icon={<DeleteIcon />} 
              label="Supprimer" 
              onClick={() => handleDelete(params.id as string)} 
            />
          ];
        }
        return [];
      },
      flex: 1
    }
  ];

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '400px' }}>
        <CircularProgress size={60} />
      </Box>
    );
  }

  return (
    <Paper sx={{
      p: 4,
      borderRadius: 4,
      boxShadow: '0 8px 32px 0 rgba(0,0,0,0.1)',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
      mt: 2
    }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 3 }}>
        <Avatar 
          sx={{ 
            bgcolor: 'primary.main',
            width: 48,
            height: 48,
            boxShadow: '0 4px 16px rgba(25, 118, 210, 0.3)',
          }}
        >
          <AssignmentIcon sx={{ fontSize: 24 }} />
        </Avatar>
        <Typography 
          variant="h5" 
          sx={{ 
            fontWeight: 700, 
            color: 'primary.main',
            textShadow: '0 2px 4px rgba(0,0,0,0.1)',
          }}
        >
          Gestion des Projets
        </Typography>
      </Box>
      
      <div style={{ height: 600, width: '100%' }}>
        <DataGrid
          rows={projects || []}
          columns={columns}
          getRowId={(row: any) => row.id}
          sx={{
            borderRadius: 3,
            background: 'rgba(255,255,255,0.95)',
            boxShadow: '0 4px 20px 0 rgba(0,0,0,0.08)',
            border: 'none',
            '& .MuiDataGrid-columnHeaders': {
              background: 'linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%)',
              fontWeight: 700,
              fontSize: 16,
              color: '#1976d2',
              borderTopLeftRadius: 12,
              borderTopRightRadius: 12,
              borderBottom: '2px solid #1976d2',
            },
            '& .MuiDataGrid-row': {
              transition: 'all 0.2s ease',
              '&:hover': {
                background: 'rgba(25, 118, 210, 0.08)',
                transform: 'translateY(-1px)',
                boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
              }
            },
            '& .MuiDataGrid-cell': {
              fontSize: 15,
              borderBottom: '1px solid #e3e3e3',
              padding: '12px 16px',
            },
            '& .MuiDataGrid-footerContainer': {
              background: 'linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%)',
              borderBottomLeftRadius: 12,
              borderBottomRightRadius: 12,
              borderTop: '2px solid #1976d2',
            },
            '& .MuiDataGrid-virtualScroller': {
              borderRadius: 12,
            }
          }}
        />
      </div>
    </Paper>
  );
};

export default Projects; 

# ==== client/src/pages/Fields.tsx ====

// client/src/pages/Fields.tsx

import React, { useEffect, useState } from 'react';
import { DataGrid, GridColDef, GridActionsCellItem } from '@mui/x-data-grid';
import { 
    Paper, Typography, CircularProgress, Box, Avatar, Chip,
    Dialog, DialogTitle, DialogContent, DialogActions, Button, TextField, MenuItem 
} from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import AgricultureIcon from '@mui/icons-material/Agriculture';
import api from '../services/api';
import { useAuth } from '../context/AuthContext';

interface Field {
  id: string;
  name: string;
  location: string;
  totalSurfaceM2: number;
  freeSurfaceM2: number;
  status: 'ACTIVE' | 'INACTIVE';
  notes?: string;
  projects?: any[];
  reservations?: any[];
}

const getStatusColor = (status: string) => {
  switch (status) {
    case 'ACTIVE': return '#388e3c';
    case 'INACTIVE': return '#d32f2f';
    default: return '#757575';
  }
};

const getStatusLabel = (status: string) => {
  switch (status) {
    case 'ACTIVE': return 'Actif';
    case 'INACTIVE': return 'Inactif';
    default: return status || 'Inconnu';
  }
};

const Fields: React.FC = () => {
  const [fields, setFields] = useState<Field[]>([]);
  const [loading, setLoading] = useState(true);
  
  // FIX: State for handling the edit dialog
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [selectedField, setSelectedField] = useState<Field | null>(null);
  const [editFormData, setEditFormData] = useState<Partial<Field>>({});

  const { user } = useAuth();

  useEffect(() => {
    const fetchFields = async () => {
      try {
        const res = await api.get('/fields');
        setFields(res.data.fields || res.data);
      } catch (err) {
        console.error("Failed to fetch fields", err);
        setFields([]);
      } finally {
        setLoading(false);
      }
    };
    fetchFields();
  }, []);

  // FIX: Updated handleEdit to open the dialog and populate form data
  const handleEdit = (field: Field) => {
    setSelectedField(field);
    setEditFormData({
      name: field.name,
      location: field.location,
      totalSurfaceM2: field.totalSurfaceM2,
      status: field.status,
      notes: field.notes,
    });
    setEditDialogOpen(true);
  };

  const handleEditDialogClose = () => {
    setEditDialogOpen(false);
    setSelectedField(null);
    setEditFormData({});
  };

  // FIX: Added function to save changes
  const handleEditSave = async () => {
    if (!selectedField) return;
    try {
      const res = await api.put(`/fields/${selectedField.id}`, editFormData);
      setFields(fields.map(f => f.id === selectedField.id ? res.data.field : f));
      handleEditDialogClose();
    } catch (err) {
      alert('√âchec de la mise √† jour du champ');
      console.error(err);
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('√ätes-vous s√ªr de vouloir supprimer ce champ ?')) {
      try {
        await api.delete(`/fields/${id}`);
        setFields(fields.filter(f => f.id !== id));
      } catch (err) {
        alert('√âchec de la suppression du champ. Assurez-vous qu\'il n\'a pas de projets ou r√©servations actives.');
      }
    }
  };

  const columns: GridColDef[] = [
    { field: 'name', headerName: 'Nom du Champ', flex: 1 },
    { field: 'location', headerName: 'Localisation', flex: 1 },
    { field: 'totalSurfaceM2', headerName: 'Surface Totale (m¬≤)', flex: 1 },
    { field: 'freeSurfaceM2', headerName: 'Surface Libre (m¬≤)', flex: 1 },
    { 
      field: 'status', 
      headerName: 'Statut', 
      flex: 1,
      renderCell: (params) => (
        <Chip 
          label={getStatusLabel(params.value)} 
          size="small" 
          sx={{ bgcolor: getStatusColor(params.value), color: '#fff', fontWeight: 600 }} 
        />
      )
    },
    {
      field: 'actions',
      type: 'actions',
      headerName: 'Actions',
      getActions: (params) => {
        if (user?.role === 'ADMIN') {
          return [
            <GridActionsCellItem 
              icon={<EditIcon />} 
              label="Modifier" 
              onClick={() => handleEdit(params.row as Field)} 
            />, 
            <GridActionsCellItem 
              icon={<DeleteIcon />} 
              label="Supprimer" 
              onClick={() => handleDelete(params.id as string)} 
            />
          ];
        }
        return [];
      },
      flex: 1
    }
  ];

  if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}><CircularProgress /></Box>;

  return (
    <Paper sx={{ p: 4, borderRadius: 4, boxShadow: 3 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 3 }}>
        <Avatar sx={{ bgcolor: 'primary.main' }}><AgricultureIcon /></Avatar>
        <Typography variant="h5" sx={{ fontWeight: 700 }}>Gestion des Champs</Typography>
      </Box>
      <div style={{ height: 600, width: '100%' }}>
        <DataGrid
          rows={fields}
          columns={columns}
          getRowId={(row) => row.id}
        />
      </div>

      {/* FIX: Edit Field Dialog */}
      <Dialog open={editDialogOpen} onClose={handleEditDialogClose} fullWidth maxWidth="sm">
        <DialogTitle>Modifier le Champ</DialogTitle>
        <DialogContent>
          <TextField
            margin="dense"
            label="Nom du Champ"
            fullWidth
            value={editFormData.name || ''}
            onChange={(e) => setEditFormData({ ...editFormData, name: e.target.value })}
          />
          <TextField
            margin="dense"
            label="Localisation"
            fullWidth
            value={editFormData.location || ''}
            onChange={(e) => setEditFormData({ ...editFormData, location: e.target.value })}
          />
          <TextField
            margin="dense"
            label="Surface Totale (m¬≤)"
            type="number"
            fullWidth
            value={editFormData.totalSurfaceM2 || ''}
            onChange={(e) => setEditFormData({ ...editFormData, totalSurfaceM2: parseFloat(e.target.value) })}
          />
          <TextField
            margin="dense"
            label="Statut"
            select
            fullWidth
            value={editFormData.status || ''}
            onChange={(e) => setEditFormData({ ...editFormData, status: e.target.value as 'ACTIVE' | 'INACTIVE' })}
          >
            <MenuItem value="ACTIVE">Actif</MenuItem>
            <MenuItem value="INACTIVE">Inactif</MenuItem>
          </TextField>
          <TextField
            margin="dense"
            label="Notes"
            fullWidth
            multiline
            rows={3}
            value={editFormData.notes || ''}
            onChange={(e) => setEditFormData({ ...editFormData, notes: e.target.value })}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleEditDialogClose}>Annuler</Button>
          <Button onClick={handleEditSave} variant="contained">Enregistrer</Button>
        </DialogActions>
      </Dialog>
    </Paper>
  );
};

export default Fields;

# ==== client/src/pages/Inventory.tsx ====

import React, { useEffect, useState } from 'react';
import { DataGrid, GridColDef, GridActionsCellItem } from '@mui/x-data-grid';
import { Paper, Typography, CircularProgress, Box, Avatar, Chip } from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import InventoryIcon from '@mui/icons-material/Inventory';
import api from '../services/api';
import { useAuth } from '../context/AuthContext';

interface InventoryItem {
  id: string;
  designation: string;
  stockQty: number;
  unit: string;
  condition: string;
  location: string;
}

const getConditionColor = (condition: string) => {
  switch (condition?.toLowerCase()) {
    case 'new':
    case 'nouveau':
      return '#388e3c';
    case 'good':
    case 'bon':
      return '#1976d2';
    case 'fair':
    case 'moyen':
      return '#f57c00';
    case 'poor':
    case 'mauvais':
      return '#d32f2f';
    default:
      return '#757575';
  }
};

const getConditionLabel = (condition: string) => {
  switch (condition?.toLowerCase()) {
    case 'new':
      return 'Nouveau';
    case 'good':
      return 'Bon';
    case 'fair':
      return 'Moyen';
    case 'poor':
      return 'Mauvais';
    default:
      return condition || 'Inconnu';
  }
};

const Inventory: React.FC = () => {
  const [items, setItems] = useState<InventoryItem[]>([]);
  const [loading, setLoading] = useState(true);
  const { user } = useAuth();

  useEffect(() => {
    const fetchItems = async () => {
      try {
        const res = await api.get('/inventory');
        setItems(res.data.inventory || res.data);
      } catch (err) {
        setItems([]);
      } finally {
        setLoading(false);
      }
    };
    fetchItems();
  }, []);

  const handleEdit = (id: string) => {
    alert('Modifier l\'article d\'inventaire ' + id);
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('√ätes-vous s√ªr de vouloir supprimer cet article ?')) {
      try {
        await api.delete(`/inventory/${id}`);
        setItems(items.filter(i => i.id !== id));
      } catch (err) {
        alert('√âchec de la suppression de l\'article');
      }
    }
  };

  const columns: GridColDef[] = [
    { 
      field: 'designation', 
      headerName: 'D√©signation', 
      flex: 1,
      renderCell: (params) => (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Avatar 
            sx={{ 
              width: 32, 
              height: 32, 
              bgcolor: 'primary.main',
              fontSize: '0.9rem',
              fontWeight: 600,
            }}
          >
            <InventoryIcon sx={{ fontSize: 16 }} />
          </Avatar>
          <Typography variant="body2" sx={{ fontWeight: 500 }}>
            {params.value}
          </Typography>
        </Box>
      )
    },
    { 
      field: 'stockQty', 
      headerName: 'Quantit√© en Stock', 
      flex: 1,
      renderCell: (params) => (
        <Typography variant="body2" sx={{ fontWeight: 600, color: 'primary.main' }}>
          {params.value?.toLocaleString() || 0}
        </Typography>
      )
    },
    { field: 'unit', headerName: 'Unit√©', flex: 1 },
    { 
      field: 'condition', 
      headerName: '√âtat', 
      flex: 1,
      renderCell: (params) => (
        <Chip 
          label={getConditionLabel(params.value)} 
          size="small" 
          sx={{ 
            bgcolor: getConditionColor(params.value),
            color: '#fff',
            fontWeight: 600,
            fontSize: '0.75rem',
          }} 
        />
      )
    },
    { field: 'location', headerName: 'Emplacement', flex: 1 },
    {
      field: 'actions',
      type: 'actions',
      headerName: 'Actions',
      getActions: (params) => {
        if (user?.role === 'ADMIN') {
          return [
            <GridActionsCellItem 
              icon={<EditIcon />} 
              label="Modifier" 
              onClick={() => handleEdit(params.id as string)} 
            />, 
            <GridActionsCellItem 
              icon={<DeleteIcon />} 
              label="Supprimer" 
              onClick={() => handleDelete(params.id as string)} 
            />
          ];
        }
        return [];
      },
      flex: 1
    }
  ];

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '400px' }}>
        <CircularProgress size={60} />
      </Box>
    );
  }

  return (
    <Paper sx={{
      p: 4,
      borderRadius: 4,
      boxShadow: '0 8px 32px 0 rgba(0,0,0,0.1)',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
      mt: 2
    }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 3 }}>
        <Avatar 
          sx={{ 
            bgcolor: 'primary.main',
            width: 48,
            height: 48,
            boxShadow: '0 4px 16px rgba(25, 118, 210, 0.3)',
          }}
        >
          <InventoryIcon sx={{ fontSize: 24 }} />
        </Avatar>
        <Typography 
          variant="h5" 
          sx={{ 
            fontWeight: 700, 
            color: 'primary.main',
            textShadow: '0 2px 4px rgba(0,0,0,0.1)',
          }}
        >
          Gestion de l'Inventaire
        </Typography>
      </Box>
      
      <div style={{ height: 600, width: '100%' }}>
        <DataGrid
          rows={items || []}
          columns={columns}
          getRowId={(row: any) => row.id}
          sx={{
            borderRadius: 3,
            background: 'rgba(255,255,255,0.95)',
            boxShadow: '0 4px 20px 0 rgba(0,0,0,0.08)',
            border: 'none',
            '& .MuiDataGrid-columnHeaders': {
              background: 'linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%)',
              fontWeight: 700,
              fontSize: 16,
              color: '#1976d2',
              borderTopLeftRadius: 12,
              borderTopRightRadius: 12,
              borderBottom: '2px solid #1976d2',
            },
            '& .MuiDataGrid-row': {
              transition: 'all 0.2s ease',
              '&:hover': {
                background: 'rgba(25, 118, 210, 0.08)',
                transform: 'translateY(-1px)',
                boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
              }
            },
            '& .MuiDataGrid-cell': {
              fontSize: 15,
              borderBottom: '1px solid #e3e3e3',
              padding: '12px 16px',
            },
            '& .MuiDataGrid-footerContainer': {
              background: 'linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%)',
              borderBottomLeftRadius: 12,
              borderBottomRightRadius: 12,
              borderTop: '2px solid #1976d2',
            },
            '& .MuiDataGrid-virtualScroller': {
              borderRadius: 12,
            }
          }}
        />
      </div>
    </Paper>
  );
};

export default Inventory; 

# ==== client/src/pages/Login.tsx ====

import React from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { TextField, Button, Box, Typography, CircularProgress, Paper, Avatar } from '@mui/material';
import { useAuth } from '../context/AuthContext';
import LockOutlinedIcon from '@mui/icons-material/LockOutlined';
import AgricultureIcon from '@mui/icons-material/Agriculture';

const schema = yup.object().shape({
  email: yup.string().email('Email invalide').required('Email requis'),
  password: yup.string().required('Mot de passe requis'),
});

type LoginFormInputs = {
  email: string;
  password: string;
};

const Login: React.FC = () => {
  const { login, loading } = useAuth();
  const { register, handleSubmit, formState: { errors }, setError } = useForm<LoginFormInputs>({
    resolver: yupResolver(schema),
  });

  const onSubmit = async (data: LoginFormInputs) => {
    try {
      await login(data.email, data.password);
      // Redirect handled by router
    } catch (err: any) {
      setError('email', { message: 'Identifiants invalides' });
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        backgroundSize: '400% 400%',
        animation: 'gradientShift 15s ease infinite',
        position: 'relative',
        '&::before': {
          content: '""',
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%), radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%)',
          pointerEvents: 'none',
        },
        '@keyframes gradientShift': {
          '0%': { backgroundPosition: '0% 50%' },
          '50%': { backgroundPosition: '100% 50%' },
          '100%': { backgroundPosition: '0% 50%' },
        }
      }}
    >
      <Paper
        elevation={24}
        sx={{
          p: 6,
          borderRadius: 4,
          width: '100%',
          maxWidth: 450,
          background: 'rgba(255, 255, 255, 0.95)',
          backdropFilter: 'blur(20px)',
          border: '1px solid rgba(255, 255, 255, 0.2)',
          boxShadow: '0 25px 50px rgba(0, 0, 0, 0.25)',
          position: 'relative',
          zIndex: 1,
        }}
      >
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', mb: 4 }}>
          <Avatar
            sx={{
              m: 1,
              bgcolor: 'primary.main',
              width: 64,
              height: 64,
              mb: 2,
              boxShadow: '0 8px 24px rgba(25, 118, 210, 0.3)',
            }}
          >
            <AgricultureIcon sx={{ fontSize: 32 }} />
          </Avatar>
          <Typography
            component="h1"
            variant="h4"
            sx={{
              fontWeight: 700,
              color: 'primary.main',
              textAlign: 'center',
              mb: 1,
              textShadow: '0 2px 4px rgba(0,0,0,0.1)',
            }}
          >
            Gestion Ferme AITTC
          </Typography>
          <Typography
            variant="h6"
            sx={{
              color: 'text.secondary',
              textAlign: 'center',
              fontWeight: 500,
              mb: 3,
            }}
          >
            Connexion
          </Typography>
        </Box>

        <form onSubmit={handleSubmit(onSubmit)}>
          <TextField
            label="Adresse email"
            type="email"
            fullWidth
            margin="normal"
            {...register('email')}
            error={!!errors.email}
            helperText={errors.email?.message}
            sx={{
              '& .MuiOutlinedInput-root': {
                borderRadius: 2,
                '&:hover fieldset': {
                  borderColor: 'primary.main',
                },
                '&.Mui-focused fieldset': {
                  borderColor: 'primary.main',
                  borderWidth: 2,
                },
              },
              '& .MuiInputLabel-root': {
                fontWeight: 500,
              },
            }}
          />
          <TextField
            label="Mot de passe"
            type="password"
            fullWidth
            margin="normal"
            {...register('password')}
            error={!!errors.password}
            helperText={errors.password?.message}
            sx={{
              '& .MuiOutlinedInput-root': {
                borderRadius: 2,
                '&:hover fieldset': {
                  borderColor: 'primary.main',
                },
                '&.Mui-focused fieldset': {
                  borderColor: 'primary.main',
                  borderWidth: 2,
                },
              },
              '& .MuiInputLabel-root': {
                fontWeight: 500,
              },
            }}
          />
          <Box sx={{ mt: 4, display: 'flex', justifyContent: 'center' }}>
            <Button
              type="submit"
              variant="contained"
              disabled={loading}
              fullWidth
              size="large"
              sx={{
                py: 1.5,
                borderRadius: 2,
                fontWeight: 600,
                fontSize: '1.1rem',
                textTransform: 'none',
                boxShadow: '0 8px 24px rgba(25, 118, 210, 0.3)',
                '&:hover': {
                  boxShadow: '0 12px 32px rgba(25, 118, 210, 0.4)',
                  transform: 'translateY(-2px)',
                },
                transition: 'all 0.3s ease',
              }}
            >
              {loading ? (
                <CircularProgress size={24} sx={{ color: 'white' }} />
              ) : (
                'Se connecter'
              )}
            </Button>
          </Box>
        </form>
      </Paper>
    </Box>
  );
};

export default Login; 

# ==== client/src/pages/Dashboard.tsx ====

// client/src/pages/Dashboard.tsx

import React, { useEffect, useState } from 'react';
import './Dashboard.css';
import Typography from '@mui/material/Typography';
import CircularProgress from '@mui/material/CircularProgress';
import { PieChart, Pie, Cell, Tooltip, Legend, BarChart, Bar, XAxis, YAxis, ResponsiveContainer } from 'recharts';
import api from '../services/api';
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import Box from '@mui/material/Box';

const COLORS = ['#3B4252', '#5E81AC', '#A3BE8C', '#EBCB8B', '#BF616A', '#88C0D0'];
const FIELD_COLORS = ['#A3BE8C', '#BF616A'];

const Dashboard: React.FC = () => {
  const [loading, setLoading] = useState(true);
  const [projectStats, setProjectStats] = useState<any[]>([]);
  const [fieldStats, setFieldStats] = useState<any>({ available: 0, unavailable: 0 });
  const [clientStats, setClientStats] = useState<any[]>([]);
  const [supervisorStats, setSupervisorStats] = useState<any[]>([]);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        const projRes = await api.get('/projects');
        const projects = projRes.data.projects || projRes.data;
        const statusMap: Record<string, number> = {};
        projects.forEach((p: any) => {
          const statusLabel = p.status.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase());
          statusMap[statusLabel] = (statusMap[statusLabel] || 0) + 1;
        });
        setProjectStats(Object.entries(statusMap).map(([name, value]) => ({ name, value })));

        const fieldsRes = await api.get('/fields');
        const fields = fieldsRes.data.fields || fieldsRes.data;
        const available = fields.filter((f: any) => f.status === 'ACTIVE').length;
        setFieldStats({ available, unavailable: fields.length - available });
        
        const clientEntityMap: Record<string, number> = {};
        projects.forEach((p: any) => {
          const entityName = p.client?.entity?.name || p.client?.name || 'Inconnu';
          clientEntityMap[entityName] = (clientEntityMap[entityName] || 0) + 1;
        });
        setClientStats(Object.entries(clientEntityMap).map(([name, value]) => ({ name, value })));

        const supervisorMap: Record<string, number> = {};
        projects.forEach((p: any) => {
          if (p.supervisor?.name) supervisorMap[p.supervisor.name] = (supervisorMap[p.supervisor.name] || 0) + 1;
        });
        setSupervisorStats(Object.entries(supervisorMap).map(([name, value]) => ({ name, value })));

      } catch (err) {
        console.error("Failed to fetch dashboard stats:", err);
      } finally {
        setLoading(false);
      }
    };
    fetchStats();
  }, []);

  if (loading) {
    return (
      <div className="dashboard-root dashboard-loading">
        <CircularProgress size={60} />
        <Typography variant="h6" className="dashboard-loading-text">
          Chargement du tableau de bord...
        </Typography>
      </div>
    );
  }

  return (
    <div className="dashboard-root">
      <div className="dashboard-header">
        <Typography variant="h3" className="dashboard-title">
          Tableau de Bord Ferme AITTC
        </Typography>
      </div>
      <div className="dashboard-cards">
        <Card className="dashboard-card">
          <CardContent sx={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column' }}>
            <Typography variant="h6" className="dashboard-card-title">Statut des Projets</Typography>
            <Box className="dashboard-chart-container">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie 
                    data={projectStats} 
                    dataKey="value" 
                    nameKey="name" 
                    cx="50%" 
                    cy="50%" 
                    outerRadius={80}
                  >
                    {projectStats.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </CardContent>
        </Card>
        <Card className="dashboard-card">
          <CardContent sx={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column' }}>
            <Typography variant="h6" className="dashboard-card-title">Disponibilit√© des Champs</Typography>
            <Box className="dashboard-chart-container">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie 
                    data={[
                      { name: 'Disponible', value: fieldStats.available },
                      { name: 'Indisponible', value: fieldStats.unavailable }
                    ]} 
                    dataKey="value" 
                    nameKey="name" 
                    cx="50%" 
                    cy="50%" 
                    outerRadius={80}
                  >
                    <Cell fill={FIELD_COLORS[0]} />
                    <Cell fill={FIELD_COLORS[1]} />
                  </Pie>
                  <Tooltip />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </CardContent>
        </Card>
        <Card className="dashboard-card">
          <CardContent sx={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column' }}>
            <Typography variant="h6" className="dashboard-card-title">Projets par Client</Typography>
            <Box className="dashboard-chart-container">
              <ResponsiveContainer width="100%" height="100%">
                {/* FIX: Added margin to give Y-axis labels space */}
                <BarChart data={clientStats} layout="vertical" margin={{ left: 30 }}>
                  <XAxis type="number" allowDecimals={false} />
                  <YAxis dataKey="name" type="category" width={80} tick={{ fontSize: 10 }} />
                  <Tooltip />
                  <Bar dataKey="value" barSize={20} radius={[4, 4, 0, 0]}>
                    {clientStats.map((entry, index) => (
                      <Cell key={`bar-client-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Bar>
                </BarChart>
              </ResponsiveContainer>
            </Box>
          </CardContent>
        </Card>
        <Card className="dashboard-card">
          <CardContent sx={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column' }}>
            <Typography variant="h6" className="dashboard-card-title">Projets par Superviseur</Typography>
            <Box className="dashboard-chart-container">
              <ResponsiveContainer width="100%" height="100%">
                {/* FIX: Added margin to give Y-axis labels space */}
                <BarChart data={supervisorStats} layout="vertical" margin={{ left: 30 }}>
                   <XAxis type="number" allowDecimals={false} />
                  <YAxis dataKey="name" type="category" width={80} tick={{ fontSize: 10 }} />
                  <Tooltip />
                  <Bar dataKey="value" barSize={20} radius={[4, 4, 0, 0]}>
                    {supervisorStats.map((entry, index) => (
                      <Cell key={`bar-sup-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Bar>
                </BarChart>
              </ResponsiveContainer>
            </Box>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default Dashboard;

# ==== client/src/pages/Dashboard.css ====

/* client/src/pages/Dashboard.css */
.dashboard-root {
    width: 100%;
    padding: 16px;
    box-sizing: border-box;
  }
  
  .dashboard-loading {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 80vh;
  }
  
  .dashboard-loading-text {
    margin-top: 16px;
  }
  
  .dashboard-header {
    text-align: center;
    margin-bottom: 32px;
  }
  
  .dashboard-title {
    font-weight: 800;
    color: #232946;
  }
  
  .dashboard-cards {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 24px;
  }
  
  .dashboard-card {
    flex: 1 1 380px; /* Flex-grow, flex-shrink, flex-basis */
    max-width: 450px;
    min-height: 380px; /* Ensure cards have enough height for content */
    display: flex;
    flex-direction: column;
    border-radius: 16px !important;
    box-shadow: 0 4px 20px rgba(44, 62, 80, 0.1) !important;
  }
  
  .dashboard-card-title {
    font-size: 1.1rem !important;
    font-weight: 700 !important;
    text-align: center;
    margin-bottom: 16px !important;
  }
  
  .dashboard-chart-container {
    flex-grow: 1; /* Allow chart to take remaining space */
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

# ==== client/src/pages/Users.tsx ====

import React, { useEffect, useState } from 'react';
import { DataGrid, GridColDef, GridActionsCellItem } from '@mui/x-data-grid';
import { Paper, Typography, CircularProgress, Dialog, DialogTitle, DialogContent, DialogActions, Button, TextField, MenuItem, Box, Avatar, Chip } from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import PeopleIcon from '@mui/icons-material/People';
import api from '../services/api';
import { useAuth } from '../context/AuthContext';

interface User {
  id: string;
  name: string;
  email: string;
  role: string;
  entity?: { name: string };
}

const roleOptions = [
  { value: 'ADMIN', label: 'Administrateur' },
  { value: 'SUPERVISOR', label: 'Superviseur' },
  { value: 'CLIENT', label: 'Client' }
];

const getRoleColor = (role: string) => {
  switch (role) {
    case 'ADMIN': return '#d32f2f';
    case 'SUPERVISOR': return '#1976d2';
    case 'CLIENT': return '#388e3c';
    default: return '#757575';
  }
};

const getRoleLabel = (role: string) => {
  switch (role) {
    case 'ADMIN': return 'Administrateur';
    case 'SUPERVISOR': return 'Superviseur';
    case 'CLIENT': return 'Client';
    default: return role;
  }
};

const Users: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [editUser, setEditUser] = useState<User | null>(null);
  const [editForm, setEditForm] = useState({ name: '', email: '', role: 'CLIENT' });
  const [saving, setSaving] = useState(false);
  const { user } = useAuth();

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const res = await api.get('/users');
        setUsers(res.data.users || res.data);
      } catch (err) {
        setUsers([]);
      } finally {
        setLoading(false);
      }
    };
    fetchUsers();
  }, []);

  const handleEdit = (id: string) => {
    const user = users.find(u => u.id === id);
    if (user) {
      setEditUser(user);
      setEditForm({ name: user.name, email: user.email, role: user.role });
    }
  };

  const handleEditChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setEditForm({ ...editForm, [e.target.name]: e.target.value });
  };

  const handleEditSave = async () => {
    if (!editUser) return;
    setSaving(true);
    try {
      const res = await api.put(`/users/${editUser.id}`, editForm);
      setUsers(users.map(u => u.id === editUser.id ? res.data : u));
      setEditUser(null);
    } catch (err) {
      alert('√âchec de la mise √† jour de l\'utilisateur');
    } finally {
      setSaving(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('√ätes-vous s√ªr de vouloir supprimer cet utilisateur ?')) {
      try {
        await api.delete(`/users/${id}`);
        setUsers(users.filter(u => u.id !== id));
      } catch (err) {
        alert('√âchec de la suppression de l\'utilisateur');
      }
    }
  };

  const columns: GridColDef[] = [
    { 
      field: 'name', 
      headerName: 'Nom', 
      flex: 1,
      renderCell: (params) => (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Avatar 
            sx={{ 
              width: 32, 
              height: 32, 
              bgcolor: getRoleColor(params.row.role),
              fontSize: '0.9rem',
              fontWeight: 600,
            }}
          >
            {params.value.charAt(0).toUpperCase()}
          </Avatar>
          <Typography variant="body2" sx={{ fontWeight: 500 }}>
            {params.value}
          </Typography>
        </Box>
      )
    },
    { field: 'email', headerName: 'Email', flex: 1 },
    { 
      field: 'role', 
      headerName: 'R√¥le', 
      flex: 1,
      renderCell: (params) => (
        <Chip 
          label={getRoleLabel(params.value)} 
          size="small" 
          sx={{ 
            bgcolor: getRoleColor(params.value),
            color: '#fff',
            fontWeight: 600,
            fontSize: '0.75rem',
          }} 
        />
      )
    },
    { 
      field: 'entity', 
      headerName: 'Entit√©', 
      flex: 1, 
      valueGetter: (params: any) => params.row?.entity?.name || 'Aucune' 
    },
    {
      field: 'actions',
      type: 'actions',
      headerName: 'Actions',
      getActions: (params) => {
        if (user?.role === 'ADMIN') {
          return [
            <GridActionsCellItem 
              icon={<EditIcon />} 
              label="Modifier" 
              onClick={() => handleEdit(params.id as string)} 
            />, 
            <GridActionsCellItem 
              icon={<DeleteIcon />} 
              label="Supprimer" 
              onClick={() => handleDelete(params.id as string)} 
            />
          ];
        }
        return [];
      },
      flex: 1
    }
  ];

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '400px' }}>
        <CircularProgress size={60} />
      </Box>
    );
  }

  return (
    <Paper sx={{
      p: 4,
      borderRadius: 4,
      boxShadow: '0 8px 32px 0 rgba(0,0,0,0.1)',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
      mt: 2
    }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 3 }}>
        <Avatar 
          sx={{ 
            bgcolor: 'primary.main',
            width: 48,
            height: 48,
            boxShadow: '0 4px 16px rgba(25, 118, 210, 0.3)',
          }}
        >
          <PeopleIcon sx={{ fontSize: 24 }} />
        </Avatar>
        <Typography 
          variant="h5" 
          sx={{ 
            fontWeight: 700, 
            color: 'primary.main',
            textShadow: '0 2px 4px rgba(0,0,0,0.1)',
          }}
        >
          Gestion des Utilisateurs
        </Typography>
      </Box>
      
      <div style={{ height: 600, width: '100%' }}>
        <DataGrid
          rows={users || []}
          columns={columns}
          getRowId={(row: any) => row.id}
          sx={{
            borderRadius: 3,
            background: 'rgba(255,255,255,0.95)',
            boxShadow: '0 4px 20px 0 rgba(0,0,0,0.08)',
            border: 'none',
            '& .MuiDataGrid-columnHeaders': {
              background: 'linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%)',
              fontWeight: 700,
              fontSize: 16,
              color: '#1976d2',
              borderTopLeftRadius: 12,
              borderTopRightRadius: 12,
              borderBottom: '2px solid #1976d2',
            },
            '& .MuiDataGrid-row': {
              transition: 'all 0.2s ease',
              '&:hover': {
                background: 'rgba(25, 118, 210, 0.08)',
                transform: 'translateY(-1px)',
                boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
              }
            },
            '& .MuiDataGrid-cell': {
              fontSize: 15,
              borderBottom: '1px solid #e3e3e3',
              padding: '12px 16px',
            },
            '& .MuiDataGrid-footerContainer': {
              background: 'linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%)',
              borderBottomLeftRadius: 12,
              borderBottomRightRadius: 12,
              borderTop: '2px solid #1976d2',
            },
            '& .MuiDataGrid-virtualScroller': {
              borderRadius: 12,
            }
          }}
        />
      </div>
      
      <Dialog 
        open={!!editUser} 
        onClose={() => setEditUser(null)}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: {
            borderRadius: 3,
            boxShadow: '0 20px 60px rgba(0,0,0,0.2)',
          }
        }}
      >
        <DialogTitle sx={{ 
          fontWeight: 700, 
          color: 'primary.main',
          borderBottom: '2px solid #e0eafc',
          pb: 2,
        }}>
          Modifier l'Utilisateur
        </DialogTitle>
        <DialogContent sx={{ pt: 3 }}>
          <TextField
            margin="dense"
            label="Nom"
            name="name"
            value={editForm.name}
            onChange={handleEditChange}
            fullWidth
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="Email"
            name="email"
            value={editForm.email}
            onChange={handleEditChange}
            fullWidth
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="R√¥le"
            name="role"
            value={editForm.role}
            onChange={handleEditChange}
            select
            fullWidth
            sx={{ mb: 2 }}
          >
            {roleOptions.map(role => (
              <MenuItem key={role.value} value={role.value}>
                {role.label}
              </MenuItem>
            ))}
          </TextField>
          <TextField
            margin="dense"
            label="Entit√©"
            name="entity"
            value={editUser?.entity?.name || 'Aucune'}
            fullWidth
            disabled
            sx={{ mb: 2 }}
          />
        </DialogContent>
        <DialogActions sx={{ p: 3, pt: 1 }}>
          <Button 
            onClick={() => setEditUser(null)} 
            disabled={saving}
            variant="outlined"
            sx={{ borderRadius: 2, px: 3 }}
          >
            Annuler
          </Button>
          <Button 
            onClick={handleEditSave} 
            disabled={saving} 
            variant="contained"
            sx={{ borderRadius: 2, px: 3 }}
          >
            {saving ? 'Enregistrement...' : 'Enregistrer'}
          </Button>
        </DialogActions>
      </Dialog>
    </Paper>
  );
};

export default Users; 

# ==== client/src/pages/Clients.tsx ====

import React, { useEffect, useState } from 'react';
import { DataGrid, GridColDef, GridActionsCellItem } from '@mui/x-data-grid';
import { Paper, Typography, CircularProgress, Button, Dialog, DialogTitle, DialogContent, List, ListItem, ListItemText, Box, Avatar, Chip } from '@mui/material';
import VisibilityIcon from '@mui/icons-material/Visibility';
import BusinessIcon from '@mui/icons-material/Business';
import api from '../services/api';

interface Entity {
  id: string;
  name: string;
  users: { id: string; name: string; email: string }[];
  projects: { id: string; title: string; field: { name: string }; supervisor: { name: string } }[];
}

const Clients: React.FC = () => {
  const [entities, setEntities] = useState<Entity[]>([]);
  const [loading, setLoading] = useState(true);
  const [selected, setSelected] = useState<any | null>(null);

  useEffect(() => {
    const fetchEntities = async () => {
      try {
        const res = await api.get('/entities');
        setEntities(res.data.entities || res.data);
      } catch (err) {
        setEntities([]);
      } finally {
        setLoading(false);
      }
    };
    fetchEntities();
  }, []);

  const columns: GridColDef[] = [
    { 
      field: 'name', 
      headerName: 'Nom de l\'Entit√©', 
      flex: 1,
      renderCell: (params) => (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Avatar 
            sx={{ 
              width: 32, 
              height: 32, 
              bgcolor: 'primary.main',
              fontSize: '0.9rem',
              fontWeight: 600,
            }}
          >
            <BusinessIcon sx={{ fontSize: 16 }} />
          </Avatar>
          <Typography variant="body2" sx={{ fontWeight: 500 }}>
            {params.value}
          </Typography>
        </Box>
      )
    },
    { 
      field: 'users', 
      headerName: 'Utilisateurs', 
      flex: 1, 
      valueGetter: (params: any) => {
        const userNames = params.row.users?.map((u: any) => u.name) || [];
        return userNames.length > 0 ? userNames.join(', ') : 'Aucun utilisateur';
      },
      renderCell: (params) => (
        <Chip 
          label={`${params.row.users?.length || 0} utilisateur(s)`} 
          size="small" 
          sx={{ 
            bgcolor: 'primary.main',
            color: '#fff',
            fontWeight: 600,
            fontSize: '0.75rem',
          }} 
        />
      )
    },
    { 
      field: 'projects', 
      headerName: 'Projets', 
      flex: 1, 
      valueGetter: (params: any) => {
        const projectTitles = params.row.projects?.map((p: any) => p.title) || [];
        return projectTitles.length > 0 ? projectTitles.join(', ') : 'Aucun projet';
      },
      renderCell: (params) => (
        <Chip 
          label={`${params.row.projects?.length || 0} projet(s)`} 
          size="small" 
          sx={{ 
            bgcolor: 'success.main',
            color: '#fff',
            fontWeight: 600,
            fontSize: '0.75rem',
          }} 
        />
      )
    },
    {
      field: 'details',
      headerName: 'D√©tails',
      type: 'actions',
      getActions: (params: any) => [
        <GridActionsCellItem 
          icon={<VisibilityIcon />} 
          label="Voir les d√©tails" 
          onClick={() => setSelected(params.row)} 
        />
      ],
      flex: 1
    }
  ];

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '400px' }}>
        <CircularProgress size={60} />
      </Box>
    );
  }

  return (
    <Paper sx={{
      p: 4,
      borderRadius: 4,
      boxShadow: '0 8px 32px 0 rgba(0,0,0,0.1)',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
      mt: 2
    }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 3 }}>
        <Avatar 
          sx={{ 
            bgcolor: 'primary.main',
            width: 48,
            height: 48,
            boxShadow: '0 4px 16px rgba(25, 118, 210, 0.3)',
          }}
        >
          <BusinessIcon sx={{ fontSize: 24 }} />
        </Avatar>
        <Typography 
          variant="h5" 
          sx={{ 
            fontWeight: 700, 
            color: 'primary.main',
            textShadow: '0 2px 4px rgba(0,0,0,0.1)',
          }}
        >
          Gestion des Clients / Entit√©s
        </Typography>
      </Box>
      
      <div style={{ height: 600, width: '100%' }}>
        <DataGrid
          rows={entities || []}
          columns={columns}
          getRowId={(row: any) => row.id}
          sx={{
            borderRadius: 3,
            background: 'rgba(255,255,255,0.95)',
            boxShadow: '0 4px 20px 0 rgba(0,0,0,0.08)',
            border: 'none',
            '& .MuiDataGrid-columnHeaders': {
              background: 'linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%)',
              fontWeight: 700,
              fontSize: 16,
              color: '#1976d2',
              borderTopLeftRadius: 12,
              borderTopRightRadius: 12,
              borderBottom: '2px solid #1976d2',
            },
            '& .MuiDataGrid-row': {
              transition: 'all 0.2s ease',
              '&:hover': {
                background: 'rgba(25, 118, 210, 0.08)',
                transform: 'translateY(-1px)',
                boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
              }
            },
            '& .MuiDataGrid-cell': {
              fontSize: 15,
              borderBottom: '1px solid #e3e3e3',
              padding: '12px 16px',
            },
            '& .MuiDataGrid-footerContainer': {
              background: 'linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%)',
              borderBottomLeftRadius: 12,
              borderBottomRightRadius: 12,
              borderTop: '2px solid #1976d2',
            },
            '& .MuiDataGrid-virtualScroller': {
              borderRadius: 12,
            }
          }}
        />
      </div>
      
      <Dialog 
        open={!!selected} 
        onClose={() => setSelected(null)} 
        maxWidth="md" 
        fullWidth
        PaperProps={{
          sx: {
            borderRadius: 4,
            background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
            boxShadow: '0 20px 60px rgba(0,0,0,0.2)',
          }
        }}
      >
        <DialogTitle sx={{ 
          fontWeight: 700, 
          color: 'primary.main',
          borderBottom: '2px solid #e0eafc',
          pb: 2,
        }}>
          D√©tails de l'Entit√©
        </DialogTitle>
        <DialogContent sx={{ pt: 3 }}>
          {selected && (
            <>
              <Typography variant="h6" sx={{ fontWeight: 600, color: 'primary.main', mb: 2 }}>
                Utilisateurs ({selected.users?.length || 0}):
              </Typography>
              <List sx={{ mb: 3 }}>
                {selected.users?.map((u: any) => (
                  <ListItem key={u.id} sx={{ 
                    background: 'rgba(255,255,255,0.7)', 
                    borderRadius: 2, 
                    mb: 1,
                    border: '1px solid rgba(25, 118, 210, 0.1)',
                  }}>
                    <ListItemText 
                      primary={u.name} 
                      secondary={u.email}
                      primaryTypographyProps={{ fontWeight: 600 }}
                    />
                  </ListItem>
                ))}
              </List>
              
              <Typography variant="h6" sx={{ fontWeight: 600, color: 'primary.main', mb: 2 }}>
                Projets ({selected.projects?.length || 0}):
              </Typography>
              <List sx={{ mb: 3 }}>
                {selected.projects?.map((p: any) => (
                  <ListItem key={p.id} sx={{ 
                    background: 'rgba(255,255,255,0.7)', 
                    borderRadius: 2, 
                    mb: 1,
                    border: '1px solid rgba(25, 118, 210, 0.1)',
                  }}>
                    <ListItemText 
                      primary={p.title} 
                      secondary={`Champ: ${p.field?.name || 'Non assign√©'}, Superviseur: ${p.supervisor?.name || 'Non assign√©'}`}
                      primaryTypographyProps={{ fontWeight: 600 }}
                    />
                  </ListItem>
                ))}
              </List>
              
              {selected.fields && (
                <>
                  <Typography variant="h6" sx={{ fontWeight: 600, color: 'primary.main', mb: 2 }}>
                    Champs Utilis√©s ({selected.fields?.length || 0}):
                  </Typography>
                  <List>
                    {selected.fields?.map((f: any) => (
                      <ListItem key={f.id} sx={{ 
                        background: 'rgba(255,255,255,0.7)', 
                        borderRadius: 2, 
                        mb: 1,
                        border: '1px solid rgba(25, 118, 210, 0.1)',
                      }}>
                        <ListItemText 
                          primary={f.name}
                          primaryTypographyProps={{ fontWeight: 600 }}
                        />
                      </ListItem>
                    ))}
                  </List>
                </>
              )}
            </>
          )}
        </DialogContent>
      </Dialog>
    </Paper>
  );
};

export default Clients; 

# ==== client/src/pages/Reservations.tsx ====

// client/src/pages/Reservations.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Paper,
  Typography,
  CircularProgress,
  Button,
  Chip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  Snackbar,
  Card,
  CardContent,
  Divider,
  Tooltip,
  Avatar
} from '@mui/material';
import {
  Add as AddIcon,
  CheckCircle as ApproveIcon,
  Cancel as RejectIcon,
  Visibility as ViewIcon,
  Delete as DeleteIcon,
  CalendarToday as CalendarIcon,
  LocationOn as LocationIcon,
  Person as PersonIcon,
  Business as BusinessIcon,
  Event as EventIcon
} from '@mui/icons-material';
import { DataGrid, GridColDef, GridActionsCellItem, GridRenderCellParams } from '@mui/x-data-grid';
import { useAuth } from '../context/AuthContext';
import api from '../services/api';

// --- Interfaces ---
interface Field {
  id: string;
  name: string;
  location: string;
  totalSurfaceM2: number;
  freeSurfaceM2: number;
  status: string;
}

interface User {
  id: string;
  name: string;
  email: string;
  role: string;
}

interface Reservation {
  id: string;
  clientId: string;
  fieldId: string;
  surfaceM2Requested: number;
  startRequested: string;
  endRequested: string;
  status: 'PENDING' | 'APPROVED' | 'REJECTED';
  decisionDate?: string;
  supervisorId?: string;
  createdAt: string;
  updatedAt: string;
  client?: {
    id: string;
    name: string;
    email: string;
    entity?: {
      id: string;
      name: string;
    };
  };
  field?: {
    id: string;
    name: string;
    location: string;
    totalSurfaceM2: number;
    freeSurfaceM2: number;
  };
  supervisor?: {
    id: string;
    name: string;
    email: string;
  };
  project?: {
    id: string;
    title: string;
    status: string;
  };
}

const getStatusLabel = (status: string) => {
  switch (status) {
    case 'PENDING': return 'En attente';
    case 'APPROVED': return 'Approuv√©e';
    case 'REJECTED': return 'Rejet√©e';
    default: return status;
  }
};

const Reservations: React.FC = () => {
  const { user } = useAuth();
  const [reservations, setReservations] = useState<Reservation[]>([]);
  const [fields, setFields] = useState<Field[]>([]);
  const [supervisors, setSupervisors] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [detailsDialogOpen, setDetailsDialogOpen] = useState(false);
  const [selectedReservation, setSelectedReservation] = useState<Reservation | null>(null);
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' }>({
    open: false,
    message: '',
    severity: 'success'
  });

  const [formData, setFormData] = useState({
    fieldId: '',
    surfaceM2Requested: '',
    startRequested: '',
    endRequested: '',
  });

  const [decisionData, setDecisionData] = useState({
    status: 'APPROVED' as 'APPROVED' | 'REJECTED',
    supervisorId: ''
  });

  useEffect(() => {
    if (user) {
      fetchData();
    }
  }, [user]);

  const fetchData = async () => {
    setLoading(true);
    try {
      const [reservationsRes, fieldsRes] = await Promise.all([
        api.get('/reservations'),
        api.get('/fields')
      ]);

      setReservations(reservationsRes.data.reservations || reservationsRes.data);
      setFields(fieldsRes.data.fields || fieldsRes.data);

      if (user?.role === 'ADMIN') {
        const supervisorsRes = await api.get('/users?role=SUPERVISOR');
        setSupervisors(supervisorsRes.data.users || supervisorsRes.data);
      }
    } catch (err) {
      console.error('Erreur lors du chargement des donn√©es:', err);
      setSnackbar({ open: true, message: "Erreur de chargement des donn√©es.", severity: 'error' });
    } finally {
      setLoading(false);
    }
  };

  const handleCreateReservation = async () => {
    try {
      await api.post('/reservations', {
        fieldId: formData.fieldId,
        surfaceM2Requested: parseFloat(formData.surfaceM2Requested),
        startRequested: formData.startRequested,
        endRequested: formData.endRequested,
      });
      fetchData();
      setCreateDialogOpen(false);
      setFormData({ fieldId: '', surfaceM2Requested: '', startRequested: '', endRequested: '' });
      setSnackbar({ open: true, message: 'R√©servation cr√©√©e avec succ√®s !', severity: 'success' });
    } catch (err: any) {
      setSnackbar({
        open: true,
        message: err.response?.data?.message || '√âchec de la cr√©ation de la r√©servation',
        severity: 'error'
      });
    }
  };

  const handleApproveReject = async () => {
    if (!selectedReservation) return;
    try {
      await api.patch(`/reservations/${selectedReservation.id}/status`, decisionData);
      fetchData();
      setDetailsDialogOpen(false);
      setSelectedReservation(null);
      setDecisionData({ status: 'APPROVED', supervisorId: '' });
      setSnackbar({
        open: true,
        message: `R√©servation ${decisionData.status === 'APPROVED' ? 'approuv√©e' : 'rejet√©e'} avec succ√®s !`,
        severity: 'success'
      });
    } catch (err: any) {
      setSnackbar({
        open: true,
        message: err.response?.data?.message || '√âchec de la mise √† jour de la r√©servation',
        severity: 'error'
      });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('√ätes-vous s√ªr de vouloir supprimer cette r√©servation ?')) {
      try {
        await api.delete(`/reservations/${id}`);
        setReservations(reservations.filter(r => r.id !== id));
        setSnackbar({ open: true, message: 'R√©servation supprim√©e avec succ√®s !', severity: 'success' });
      } catch (err: any) {
        setSnackbar({
          open: true,
          message: err.response?.data?.message || '√âchec de la suppression de la r√©servation',
          severity: 'error'
        });
      }
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING': return 'warning';
      case 'APPROVED': return 'success';
      case 'REJECTED': return 'error';
      default: return 'default';
    }
  };
  
  const columns: GridColDef<Reservation>[] = [
    {
      field: 'client', headerName: 'Client', flex: 1, renderCell: (params: GridRenderCellParams) => (
        <Box>
          <Typography variant="body2" fontWeight={600}>{params.row.client?.name}</Typography>
          {params.row.client?.entity?.name && (<Typography variant="caption" color="text.secondary">{params.row.client.entity.name}</Typography>)}
        </Box>
      )
    },
    {
      field: 'field', headerName: 'Champ', flex: 1, renderCell: (params: GridRenderCellParams) => (
        <Box>
          <Typography variant="body2" fontWeight={600}>{params.row.field?.name}</Typography>
          <Typography variant="caption" color="text.secondary">{params.row.field?.location}</Typography>
        </Box>
      )
    },
    {
      field: 'surfaceM2Requested', headerName: 'Surface (m¬≤)', flex: 0.8, renderCell: (params: GridRenderCellParams) => (
        <Typography variant="body2" fontWeight={600}>{params.row.surfaceM2Requested}</Typography>
      )
    },
    {
      field: 'dates', headerName: 'P√©riode', flex: 1.2, renderCell: (params: GridRenderCellParams) => (
        <Box>
          <Typography variant="body2" fontWeight={600}>{new Date(params.row.startRequested).toLocaleDateString()}</Typography>
          <Typography variant="caption" color="text.secondary">au {new Date(params.row.endRequested).toLocaleDateString()}</Typography>
        </Box>
      )
    },
    {
      field: 'status', headerName: 'Statut', flex: 0.8, renderCell: (params: GridRenderCellParams) => (
        <Chip label={getStatusLabel(params.row.status)} color={getStatusColor(params.row.status) as any} size="small" variant="outlined" />
      )
    },
    {
      field: 'supervisor', headerName: 'Superviseur', flex: 1, renderCell: (params: GridRenderCellParams) => (
        <Typography variant="body2">{params.row.supervisor?.name || '-'}</Typography>
      )
    },
    {
      field: 'actions', type: 'actions', headerName: 'Actions', flex: 1, getActions: (params) => {
        const actions = [<GridActionsCellItem key={`view-${params.id}`} icon={<ViewIcon />} label="Voir les d√©tails" onClick={() => { setSelectedReservation(params.row); setDetailsDialogOpen(true); }} />];
        if (user?.role === 'ADMIN' && params.row.status === 'PENDING') {
          actions.push(<GridActionsCellItem key={`approve-${params.id}`} icon={<ApproveIcon color="success" />} label="Approuver" onClick={() => { setSelectedReservation(params.row); setDecisionData({ status: 'APPROVED', supervisorId: '' }); setDetailsDialogOpen(true); }} />, <GridActionsCellItem key={`reject-${params.id}`} icon={<RejectIcon color="error" />} label="Rejeter" onClick={() => { setSelectedReservation(params.row); setDecisionData({ status: 'REJECTED', supervisorId: '' }); setDetailsDialogOpen(true); }} />);
        }
        if (params.row.status === 'PENDING') {
          actions.push(<GridActionsCellItem key={`delete-${params.id}`} icon={<DeleteIcon />} label="Supprimer" onClick={() => handleDelete(params.id as string)} />);
        }
        return actions;
      }
    }
  ];

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
        <CircularProgress size={60} />
      </Box>
    );
  }

  return (
    <Box sx={{ p: 4 }}>
      <Box sx={{ mb: 4, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          <Avatar sx={{ bgcolor: 'primary.main', width: 48, height: 48, boxShadow: '0 4px 16px rgba(25, 118, 210, 0.3)', }}><EventIcon sx={{ fontSize: 24 }} /></Avatar>
          <Typography variant="h4" fontWeight={700} color="primary" sx={{ textShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>R√©servations de Champs</Typography>
        </Box>
        {user?.role === 'CLIENT' && (
          <Button variant="contained" startIcon={<AddIcon />} onClick={() => setCreateDialogOpen(true)} sx={{ background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', boxShadow: '0 4px 16px rgba(102, 126, 234, 0.3)', borderRadius: 2, px: 3, py: 1.5, fontWeight: 600, '&:hover': { background: 'linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%)', boxShadow: '0 6px 20px rgba(102, 126, 234, 0.4)', transform: 'translateY(-2px)', }, transition: 'all 0.3s ease', }}>Nouvelle R√©servation</Button>
        )}
      </Box>
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 3, mb: 4, '& > *': { flex: { xs: '1 1 100%', sm: '1 1 calc(50% - 12px)', md: '1 1 calc(25% - 18px)' }, minWidth: { xs: '100%', sm: '200px', md: '180px' } } }}>
        <Card sx={{ background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', color: 'white', borderRadius: 3, boxShadow: '0 8px 24px rgba(102, 126, 234, 0.3)', }}><CardContent><Typography variant="h6" gutterBottom>Total R√©servations</Typography><Typography variant="h4" fontWeight={700}>{reservations.length}</Typography></CardContent></Card>
        <Card sx={{ background: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', color: 'white', borderRadius: 3, boxShadow: '0 8px 24px rgba(240, 147, 251, 0.3)', }}><CardContent><Typography variant="h6" gutterBottom>En Attente</Typography><Typography variant="h4" fontWeight={700}>{reservations.filter(r => r.status === 'PENDING').length}</Typography></CardContent></Card>
        <Card sx={{ background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)', color: 'white', borderRadius: 3, boxShadow: '0 8px 24px rgba(79, 172, 254, 0.3)', }}><CardContent><Typography variant="h6" gutterBottom>Approuv√©es</Typography><Typography variant="h4" fontWeight={700}>{reservations.filter(r => r.status === 'APPROVED').length}</Typography></CardContent></Card>
        <Card sx={{ background: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)', color: 'white', borderRadius: 3, boxShadow: '0 8px 24px rgba(250, 112, 154, 0.3)', }}><CardContent><Typography variant="h6" gutterBottom>Rejet√©es</Typography><Typography variant="h4" fontWeight={700}>{reservations.filter(r => r.status === 'REJECTED').length}</Typography></CardContent></Card>
      </Box>

      <Paper sx={{ borderRadius: 4, boxShadow: '0 8px 32px rgba(0,0,0,0.1)', overflow: 'hidden' }}>
        <DataGrid rows={reservations} columns={columns} getRowId={(row) => row.id} autoHeight pageSizeOptions={[10, 25, 50]} initialState={{ pagination: { paginationModel: { page: 0, pageSize: 10 }, }, }} sx={{ border: 'none', '& .MuiDataGrid-columnHeaders': { background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', color: 'white', fontWeight: 600, fontSize: 14 }, '& .MuiDataGrid-row': { transition: 'all 0.2s', '&:hover': { background: 'rgba(102, 126, 234, 0.08)', transform: 'translateY(-1px)', boxShadow: '0 4px 12px rgba(0,0,0,0.1)' } }, '& .MuiDataGrid-cell': { borderBottom: '1px solid #f0f0f0', fontSize: 14 } }} />
      </Paper>

      <Dialog open={createDialogOpen} onClose={() => setCreateDialogOpen(false)} maxWidth="md" fullWidth PaperProps={{ sx: { borderRadius: 3, boxShadow: '0 20px 60px rgba(0,0,0,0.2)', } }}>
        <DialogTitle sx={{ background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', color: 'white', fontWeight: 600 }}>Cr√©er une Nouvelle R√©servation de Champ</DialogTitle>
        <DialogContent sx={{ pt: 3 }}>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
            <FormControl fullWidth>
              <InputLabel>Champ</InputLabel>
              <Select value={formData.fieldId} onChange={(e) => setFormData({ ...formData, fieldId: e.target.value })} label="Champ">
                {fields.filter(f => f.status?.toLowerCase() === 'active' && f.freeSurfaceM2 > 0).length === 0 ? (
                  <MenuItem value="" disabled>Aucun champ disponible</MenuItem>
                ) : (
                  fields.filter(f => f.status?.toLowerCase() === 'active' && f.freeSurfaceM2 > 0).sort((a, b) => a.name.localeCompare(b.name)).map((field) => (
                    <MenuItem key={field.id} value={field.id}>
                      {field.name} - {field.location} (Libre: {field.freeSurfaceM2}m¬≤)
                    </MenuItem>
                  ))
                )}
              </Select>
            </FormControl>
            <TextField fullWidth label="Surface (m¬≤)" type="number" value={formData.surfaceM2Requested} onChange={(e) => setFormData({ ...formData, surfaceM2Requested: e.target.value })} inputProps={{ min: 0.1, step: 0.1 }} />
            <TextField fullWidth label="Date de d√©but" type="date" value={formData.startRequested} onChange={(e) => setFormData({ ...formData, startRequested: e.target.value })} InputLabelProps={{ shrink: true }} />
            <TextField fullWidth label="Date de fin" type="date" value={formData.endRequested} onChange={(e) => setFormData({ ...formData, endRequested: e.target.value })} InputLabelProps={{ shrink: true }} />
          </Box>
        </DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button onClick={() => setCreateDialogOpen(false)}>Annuler</Button>
          <Button onClick={handleCreateReservation} variant="contained" disabled={!formData.fieldId || !formData.surfaceM2Requested || !formData.startRequested || !formData.endRequested} sx={{ borderRadius: 2, px: 3 }}>Cr√©er la R√©servation</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={detailsDialogOpen} onClose={() => setDetailsDialogOpen(false)} maxWidth="md" fullWidth PaperProps={{ sx: { borderRadius: 3, boxShadow: '0 20px 60px rgba(0,0,0,0.2)', } }}>
        <DialogTitle sx={{ background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', color: 'white', fontWeight: 600 }}>{selectedReservation?.status === 'PENDING' && user?.role === 'ADMIN' ? `Examiner la R√©servation - ${decisionData.status === 'APPROVED' ? 'Approuver' : 'Rejeter'}` : 'D√©tails de la R√©servation'}</DialogTitle>
        <DialogContent sx={{ pt: 3 }}>{selectedReservation && (<Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}><Card sx={{ background: '#f8f9fa', borderRadius: 2 }}><CardContent><Typography variant="h6" gutterBottom>Informations de R√©servation</Typography><Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2, '& > *': { flex: { xs: '1 1 100%', md: '1 1 calc(50% - 8px)' }, minWidth: { xs: '100%', md: '200px' } } }}><Box><Box display="flex" alignItems="center" mb={1}><PersonIcon sx={{ mr: 1, color: 'primary.main' }} /><Typography variant="body2"><strong>Client:</strong> {selectedReservation.client?.name}</Typography></Box>{selectedReservation.client?.entity?.name && (<Box display="flex" alignItems="center" mb={1}><BusinessIcon sx={{ mr: 1, color: 'primary.main' }} /><Typography variant="body2"><strong>Entit√©:</strong> {selectedReservation.client.entity.name}</Typography></Box>)}<Box display="flex" alignItems="center" mb={1}><LocationIcon sx={{ mr: 1, color: 'primary.main' }} /><Typography variant="body2"><strong>Champ:</strong> {selectedReservation.field?.name} ({selectedReservation.field?.location})</Typography></Box></Box><Box><Box display="flex" alignItems="center" mb={1}><CalendarIcon sx={{ mr: 1, color: 'primary.main' }} /><Typography variant="body2"><strong>P√©riode:</strong> {new Date(selectedReservation.startRequested).toLocaleDateString()} - {new Date(selectedReservation.endRequested).toLocaleDateString()}</Typography></Box><Typography variant="body2" mb={1}><strong>Surface:</strong> {selectedReservation.surfaceM2Requested} m¬≤</Typography><Typography variant="body2" mb={1}><strong>Statut:</strong><Chip label={getStatusLabel(selectedReservation.status)} color={getStatusColor(selectedReservation.status) as any} size="small" sx={{ ml: 1 }} /></Typography>{selectedReservation.supervisor && (<Typography variant="body2"><strong>Superviseur:</strong> {selectedReservation.supervisor.name}</Typography>)}</Box></Box></CardContent></Card>{selectedReservation.status === 'PENDING' && user?.role === 'ADMIN' && (<Card sx={{ background: '#fff3cd', border: '1px solid #ffeaa7', borderRadius: 2 }}><CardContent><Typography variant="h6" gutterBottom color="warning.dark">D√©cision d'Examen</Typography><Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2, '& > *': { flex: { xs: '1 1 100%', md: '1 1 calc(50% - 8px)' }, minWidth: { xs: '100%', md: '200px' } } }}><FormControl fullWidth><InputLabel>D√©cision</InputLabel><Select value={decisionData.status} onChange={(e) => setDecisionData({ ...decisionData, status: e.target.value as 'APPROVED' | 'REJECTED' })} label="D√©cision"><MenuItem value="APPROVED">Approuver</MenuItem><MenuItem value="REJECTED">Rejeter</MenuItem></Select></FormControl>{decisionData.status === 'APPROVED' && (<FormControl fullWidth><InputLabel>Assigner un Superviseur</InputLabel><Select value={decisionData.supervisorId} onChange={(e) => setDecisionData({ ...decisionData, supervisorId: e.target.value })} label="Assigner un Superviseur"><MenuItem value="">Aucun superviseur</MenuItem>{supervisors.map((supervisor) => (<MenuItem key={supervisor.id} value={supervisor.id}>{supervisor.name}</MenuItem>))}</Select></FormControl>)}</Box></CardContent></Card>)}</Box>)}</DialogContent>
        <DialogActions sx={{ p: 3 }}>
          <Button onClick={() => setDetailsDialogOpen(false)}>Fermer</Button>
          {selectedReservation?.status === 'PENDING' && user?.role === 'ADMIN' && (
            <Button onClick={handleApproveReject} variant="contained" color={decisionData.status === 'APPROVED' ? 'success' : 'error'} sx={{ borderRadius: 2, px: 3 }}>{decisionData.status === 'APPROVED' ? 'Approuver' : 'Rejeter'}</Button>
          )}
        </DialogActions>
      </Dialog>
      
      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={() => setSnackbar({ ...snackbar, open: false })}><Alert onClose={() => setSnackbar({ ...snackbar, open: false })} severity={snackbar.severity} sx={{ width: '100%' }}>{snackbar.message}</Alert></Snackbar>
    </Box>
  );
};

export default Reservations;

# ==== client/src/services/api.ts ====

import axios from 'axios';

const api = axios.create({
  baseURL: process.env.REACT_APP_API_BASE_URL,
  withCredentials: true,
});

// Add a request interceptor to include JWT token if present
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

export default api; 

# ==== src/App.tsx ====

import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import { CssBaseline } from '@mui/material';
import { AuthProvider, useAuth } from './context/AuthContext';
import Login from './pages/Login';

const theme = createTheme();

const AppRoutes = () => {
  const { user, loading } = useAuth();

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <Routes>
      <Route path="/login" element={user ? <Navigate to="/dashboard" /> : <Login />} />
      <Route path="/dashboard" element={user ? <div>Dashboard for {user.role}</div> : <Navigate to="/login" />} />
      <Route path="/" element={<Navigate to={user ? "/dashboard" : "/login"} />} />
    </Routes>
  );
};

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <AuthProvider>
        <Router>
          <AppRoutes />
        </Router>
      </AuthProvider>
    </ThemeProvider>
  );
}

export default App; 

# ==== src/server.js ====

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const { PrismaClient } = require('@prisma/client');
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const fieldRoutes = require('./routes/fields');
const projectRoutes = require('./routes/projects');
const reservationRoutes = require('./routes/reservations');
const inventoryRoutes = require('./routes/inventory');
const priceOfferRoutes = require('./routes/priceOffers');
const serviceOrderRoutes = require('./routes/serviceOrders');
const dashboardRoutes = require('./routes/dashboard');
const exportRoutes = require('./routes/exports');
const entitiesRouter = require('./routes/entities');

const app = express();
const prisma = new PrismaClient();

// Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(morgan('combined'));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.'
});
app.use('/api/', limiter);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV 
  });
});

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/fields', fieldRoutes);
app.use('/api/projects', projectRoutes);
app.use('/api/reservations', reservationRoutes);
app.use('/api/inventory', inventoryRoutes);
app.use('/api/price-offers', priceOfferRoutes);
app.use('/api/service-orders', serviceOrderRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/exports', exportRoutes);
app.use('/entities', entitiesRouter);

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      error: 'Validation Error',
      details: err.message
    });
  }
  
  if (err.name === 'UnauthorizedError') {
    return res.status(401).json({
      error: 'Unauthorized',
      message: 'Invalid or missing authentication token'
    });
  }
  
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Not Found',
    message: 'The requested resource was not found'
  });
});

const PORT = process.env.PORT || 3001;

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('Shutting down gracefully...');
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('Shutting down gracefully...');
  await prisma.$disconnect();
  process.exit(0);
});

app.listen(PORT, () => {
  console.log(`üöÄ AITTC Farm Management Server running on port ${PORT}`);
  console.log(`üìä Environment: ${process.env.NODE_ENV}`);
  console.log(`üîó Health check: http://localhost:${PORT}/health`);
});

module.exports = app; 

# ==== src/middleware/auth.js ====

const jwt = require('jsonwebtoken');
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

// Middleware to verify JWT token
const authenticateToken = async (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({
      error: 'Access Token Required',
      message: 'No authentication token provided'
    });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Get user from database to ensure they still exist and are verified
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        isVerified: true,
        entityId: true
      }
    });

    if (!user) {
      return res.status(401).json({
        error: 'Invalid Token',
        message: 'User not found'
      });
    }

    if (!user.isVerified) {
      return res.status(403).json({
        error: 'Account Not Verified',
        message: 'Please verify your email address before accessing the system'
      });
    }

    req.user = user;
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        error: 'Token Expired',
        message: 'Authentication token has expired'
      });
    }
    
    return res.status(403).json({
      error: 'Invalid Token',
      message: 'Invalid authentication token'
    });
  }
};

// Middleware to check if user has required role(s)
const requireRole = (roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        error: 'Authentication Required',
        message: 'User must be authenticated'
      });
    }

    const userRole = req.user.role;
    const allowedRoles = Array.isArray(roles) ? roles : [roles];

    if (!allowedRoles.includes(userRole)) {
      return res.status(403).json({
        error: 'Insufficient Permissions',
        message: `Access denied. Required role(s): ${allowedRoles.join(', ')}`
      });
    }

    next();
  };
};

// Middleware to check if user can access their own data or is admin
const requireOwnershipOrAdmin = (resourceType) => {
  return async (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        error: 'Authentication Required',
        message: 'User must be authenticated'
      });
    }

    // Admin can access everything
    if (req.user.role === 'ADMIN') {
      return next();
    }

    const resourceId = req.params.id || req.params.userId;
    
    if (!resourceId) {
      return res.status(400).json({
        error: 'Resource ID Required',
        message: 'Resource ID is required for ownership verification'
      });
    }

    try {
      let resource;
      
      switch (resourceType) {
        case 'user':
          resource = await prisma.user.findUnique({
            where: { id: resourceId },
            select: { id: true, role: true }
          });
          break;
        case 'reservation':
          resource = await prisma.reservation.findUnique({
            where: { id: resourceId },
            select: { id: true, clientId: true }
          });
          break;
        case 'project':
          resource = await prisma.project.findUnique({
            where: { id: resourceId },
            select: { id: true, clientId: true, supervisorId: true }
          });
          break;
        default:
          return res.status(400).json({
            error: 'Invalid Resource Type',
            message: 'Invalid resource type for ownership verification'
          });
      }

      if (!resource) {
        return res.status(404).json({
          error: 'Resource Not Found',
          message: 'The requested resource was not found'
        });
      }

      // Check ownership based on resource type
      let hasAccess = false;
      
      switch (resourceType) {
        case 'user':
          hasAccess = resource.id === req.user.id;
          break;
        case 'reservation':
          hasAccess = resource.clientId === req.user.id;
          break;
        case 'project':
          hasAccess = resource.clientId === req.user.id || resource.supervisorId === req.user.id;
          break;
      }

      if (!hasAccess) {
        return res.status(403).json({
          error: 'Access Denied',
          message: 'You can only access your own resources'
        });
      }

      next();
    } catch (error) {
      console.error('Ownership verification error:', error);
      return res.status(500).json({
        error: 'Internal Server Error',
        message: 'Error verifying resource ownership'
      });
    }
  };
};

// Middleware to check if user is supervisor for a project
const requireSupervisorAccess = async (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      error: 'Authentication Required',
      message: 'User must be authenticated'
    });
  }

  const projectId = req.params.projectId || req.params.id;
  
  if (!projectId) {
    return res.status(400).json({
      error: 'Project ID Required',
      message: 'Project ID is required for supervisor verification'
    });
  }

  try {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { id: true, supervisorId: true }
    });

    if (!project) {
      return res.status(404).json({
        error: 'Project Not Found',
        message: 'The requested project was not found'
      });
    }

    // Admin can access everything
    if (req.user.role === 'ADMIN') {
      return next();
    }

    // Check if user is the supervisor for this project
    if (project.supervisorId !== req.user.id) {
      return res.status(403).json({
        error: 'Access Denied',
        message: 'You can only access projects you are supervising'
      });
    }

    next();
  } catch (error) {
    console.error('Supervisor verification error:', error);
    return res.status(500).json({
      error: 'Internal Server Error',
      message: 'Error verifying supervisor access'
    });
  }
};

module.exports = {
  authenticateToken,
  requireRole,
  requireOwnershipOrAdmin,
  requireSupervisorAccess
}; 

# ==== src/database/seed.js ====

const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcryptjs');

const prisma = new PrismaClient();

// =========================================================================================
// DATA EXTRACTED FROM F.75 DOCUMENT
// =========================================================================================

// Entities (Departments/Organizations) from the 'D√©partement' column and other sections
const entities = [
  { name: 'AITTC', notes: 'Africa IT & Innovation Center - UM6P' },
  { name: 'AGBS', notes: 'AgroBioSciences - UM6P' },
  { name: 'BPS-AGBS', notes: 'A sub-entity of AgroBioSciences' },
  { name: 'Africane genome center(AGC)', notes: 'African Genome Center - UM6P' },
  { name: 'ESAFE', notes: 'School of Agriculture, Fertilization and Environmental Sciences - UM6P' },
  { name: 'Agri Edge', notes: 'UM6P Program' },
  { name: 'Smart Pharm', notes: 'UM6P Program' },
  { name: 'EMINES', notes: 'School of Industrial Management - UM6P' },
  { name: 'UM6P', notes: 'Universit√© Mohammed VI Polytechnique' },
  { name: 'OCP JORF LASFAR', notes: 'OCP Group - Jorf Lasfar Site' },
];

// All personnel mentioned in the document, with assigned roles and generated emails.
// Farm staff are 'SUPERVISOR', project responsibles are 'CLIENT'.
const users = [
  // Comit√© de pilotage & Farm Staff (Supervisors)
  { name: 'Younes JNAOUI', email: 'younes.jnaoui@aittc.ma', role: 'SUPERVISOR', entityName: 'AITTC' },
  { name: 'Yasmine TAOUIR', email: 'yasmine.taouir@aittc.ma', role: 'SUPERVISOR', entityName: 'AITTC' },
  { name: 'Lahoucine AIT YAHIA', email: 'lahoucine.aityahia@aittc.ma', role: 'SUPERVISOR', entityName: 'AITTC' },
  { name: 'Jelloul FNIZI', email: 'jelloul.fnizi@aittc.ma', role: 'SUPERVISOR', entityName: 'AITTC' },
  { name: 'Yassine ELBEQQAL', email: 'yassine.elbeqqal@aittc.ma', role: 'SUPERVISOR', entityName: 'AITTC' },
  { name: 'Aziz JMEL', email: 'aziz.jmel@aittc.ma', role: 'SUPERVISOR', entityName: 'AITTC' },
  { name: 'Brahim EL KAJAF', email: 'brahim.elkajaf@aittc.ma', role: 'SUPERVISOR', entityName: 'AITTC' },
  { name: 'Bouchaib ESSAIH', email: 'bouchaib.essaih@aittc.ma', role: 'SUPERVISOR', entityName: 'AITTC' },

  // Project Responsibles (Clients)
  { name: 'Fatima Ezzahra JABBOUR', email: 'fatima.jabbour@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Adnan BENAICH', email: 'adnan.benaich@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Adil EL BAOUCHI', email: 'adil.elbaouchi@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Hassan ANNAZ', email: 'hassan.annaz@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Manal MHADA', email: 'manal.mhada@agbs.ma', role: 'CLIENT', entityName: 'BPS-AGBS' },
  { name: 'Khadija AIT ELALLAM', email: 'khadija.aitelallam@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Bouchra BENMRID', email: 'bouchra.benmrid@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Khadija NASRAOUI', email: 'khadija.nasraoui@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Hamid MOUTAOUAKIL', email: 'hamid.moutaouakil@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Massamba DIOP', email: 'massamba.diop@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Aziza TANGI', email: 'aziza.tangi@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Rachid GHANI', email: 'rachid.ghani@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Dr EL HAFIDI', email: 'dr.elhafidi@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Rachida Naciri', email: 'rachida.naciri@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Mustapha El Janati', email: 'mustapha.eljanati@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Chtouki Mohamed', email: 'chtouki.mohamed@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Safi Uwase', email: 'safi.uwase@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Mohamed El mahdi EL BOUKHARI', email: 'm.elboukhari@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Bouhia Younes', email: 'bouhia.younes@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Nawal TAAIME', email: 'nawal.taaime@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Mohamed Louay MAATOUGUI', email: 'mohamed.maatougui@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Younes BOUHIYA', email: 'younes.bouhiya@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Imad KHATOUR', email: 'imad.khatour@agc.ma', role: 'CLIENT', entityName: 'Africane genome center(AGC)' },
  { name: 'Khadija EI HAZZAM', email: 'khadija.elhazzam@agbs.ma', role: 'CLIENT', entityName: 'BPS-AGBS' },
  { inconnu_client_1: true, name: 'Haitam MOULAY', email: 'haitam.moulay@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { inconnu_client_2: true, name: 'Dontien', email: 'dontien.client@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Mbarka OUTBAKAT', email: 'mbarka.outbakat@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Saida TAYIBI', email: 'saida.tayibi@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Chaimaa HAKIM', email: 'chaimaa.hakim@agbs.ma', role: 'CLIENT', entityName: 'AGBS' },
  { name: 'Dr CHOKRALLAH', email: 'dr.chokrallah@aittc.ma', role: 'CLIENT', entityName: 'AITTC' },
  { name: 'Mohamed BOULIF', email: 'mohamed.boulif@esafe.ma', role: 'CLIENT', entityName: 'ESAFE' },
];

// Physical locations (Fields) from the 'Emplacement' column
const fields = [
  { name: 'La p√©pini√®re', location: 'Ben Gu√©rir', totalSurfaceM2: 0, freeSurfaceM2: 0 },
  { name: 'Sidi El Aydi', location: 'Station exp√©rimentale Sidi El Aydi', totalSurfaceM2: 0, freeSurfaceM2: 0 },
  { name: 'Tassaout', location: 'Station exp√©rimentale Tassaout', totalSurfaceM2: 0, freeSurfaceM2: 0 },
  { name: 'La mine', location: 'Zone mini√®re Ben Gu√©rir', totalSurfaceM2: 0, freeSurfaceM2: 0 },
  { name: 'A la ferme', location: 'Ferme Ben Gu√©rir (Parcelles g√©n√©rales)', totalSurfaceM2: 0, freeSurfaceM2: 0 },
  { name: 'Site externe', location: 'Site externe (ex: OCP Jorf Lasfar)', totalSurfaceM2: 0, freeSurfaceM2: 0 },
];

// Categories of work derived from the 'Type d'activit√©' and project titles.
const activityTypes = [
  { label: 'Recherche Scientifique', description: 'Essais et projets de recherche' },
  { label: 'Production Animale', description: 'Activit√©s li√©es √† l\'√©levage' },
  { label: 'Multiplication V√©g√©tale', description: 'Multiplication de plantes et semences' },
  { label: 'Arboriculture', description: 'Culture d\'arbres fruitiers et forestiers' },
  { label: 'Maraichage', description: 'Culture de l√©gumes' },
  { label: 'C√©r√©aliculture', description: 'Culture de c√©r√©ales' },
  { label: 'Cultures Fourrag√®res', description: 'Culture de plantes destin√©es √† l\'alimentation animale' },
  { label: 'Production de PAM', description: 'Production de Plantes Aromatiques et M√©dicinales' },
  { label: 'Ornementale et Espaces Verts', description: 'Gestion des espaces verts et plantes ornementales' },
  { label: 'Agriculture de Pr√©cision', description: 'Projets utilisant des technologies de pointe (Smart Farming)' },
  { label: 'D√©veloppement et Formation', description: 'Projets de d√©veloppement, formation et apprentissage (Learning by Farming)' },
  { label: 'Commercialisation', description: 'Activit√©s de commercialisation des produits de la ferme' },
  { label: 'Gestion des D√©chets', description: 'Projets li√©s au traitement et √† la valorisation des d√©chets' },
  { label: 'R√©habilitation des Sols', description: 'Projets visant √† restaurer la qualit√© des sols' },
  { label: 'Collection et Conservation', description: 'Maintien de collections de ressources g√©n√©tiques (cactus, acacia, etc.)' },
];

// Comprehensive list of all projects and programs from both tables in the F.75 document.
const projects = [
  // --- Table 1: Recherche scientifique ---
  { title: "OCP Innovation", fieldName: "La p√©pini√®re", clientName: "Fatima Ezzahra JABBOUR", supervisorName: "Yasmine TAOUIR", surfaceM2: 30, dateStr: "09-2021 au 04-2022", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" }, // Date corrected from 04-2021
  { title: "OCP Strategy (ferme)", fieldName: "La p√©pini√®re", clientName: "Adnan BENAICH", supervisorName: "Yasmine TAOUIR", surfaceM2: 30, dateStr: "02-2021 au 12-2021", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "OCP Strategy (Station exp√©rimentale Sidi El Aydi)", fieldName: "Sidi El Aydi", clientName: "Adnan BENAICH", supervisorName: "Yasmine TAOUIR", surfaceM2: 3650, dateStr: "02-2021 au 12-2021", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "OCP Strategy (Station exp√©rimentale Tassaout)", fieldName: "Tassaout", clientName: "Adnan BENAICH", supervisorName: "Yasmine TAOUIR", surfaceM2: 3611, dateStr: "02-2021 au 12-2021", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "Multiplication des semences Vigna et Lentille", fieldName: "La p√©pini√®re", clientName: "Adil EL BAOUCHI", supervisorName: "Yasmine TAOUIR", surfaceM2: 30, dateStr: "05-2021 au 08-2021", status: "FINALISE", activityTypeLabel: "Multiplication V√©g√©tale" },
  { title: "Valorisation agronomique de la boue", fieldName: "La p√©pini√®re", clientName: "Fatima Ezzahra JABBOUR", supervisorName: "Yasmine TAOUIR", surfaceM2: 60, dateStr: "11-2021 au 02-2022", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "Le potentiel biostimulant des extraits des plantes-1", fieldName: "La p√©pini√®re", clientName: "Hassan ANNAZ", supervisorName: "Yasmine TAOUIR", surfaceM2: 20, dateStr: "11-2021 au 01-2022", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "Collection Cactus AgBS", fieldName: "La p√©pini√®re", clientName: "Manal MHADA", supervisorName: "Yasmine TAOUIR", surfaceM2: 100, dateStr: "Depuis 08-2021", status: "EN_COURS", activityTypeLabel: "Collection et Conservation" },
  { title: "R√©habilitation des sols minier par les PAM", fieldName: "La p√©pini√®re", clientName: "Khadija AIT ELALLAM", supervisorName: "Yasmine TAOUIR", surfaceM2: 3, dateStr: "11-2021 au 03-2022", status: "EN_COURS", activityTypeLabel: "R√©habilitation des Sols" },
  { title: "Test d'inoculation de la f√®ve sous stress", fieldName: "La p√©pini√®re", clientName: "Bouchra BENMRID", supervisorName: "Yasmine TAOUIR", surfaceM2: 44, dateStr: "11-2021 au 04-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Le potentiel biostimulant des extraits des plantes-2", fieldName: "La p√©pini√®re", clientName: "Hassan ANNAZ", supervisorName: "Yasmine TAOUIR", surfaceM2: 20, dateStr: "04-04-22 au 15-06-22", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Collecte et tri des d√©chets m√©nagers", fieldName: "La p√©pini√®re", clientName: "Khadija NASRAOUI", supervisorName: "Yasmine TAOUIR", surfaceM2: 0, dateStr: "Depuis 2021", status: "EN_COURS", activityTypeLabel: "Gestion des D√©chets" },
  { title: "Agroforesterie", fieldName: "La p√©pini√®re", clientName: "Massamba DIOP", supervisorName: "Yasmine TAOUIR", surfaceM2: 29160, dateStr: "12-2020 au 12-2024", status: "EN_COURS", activityTypeLabel: "Arboriculture" },
  { title: "Collection cactus AITTC", fieldName: "La p√©pini√®re", clientName: "Aziza TANGI", supervisorName: "Yasmine TAOUIR", surfaceM2: 130, dateStr: "Depuis 11-2018", status: "EN_COURS", activityTypeLabel: "Collection et Conservation" },
  { title: "D√©velopement de formulation de fertilisant(AS17)", fieldName: "La p√©pini√®re", clientName: "Rachid GHANI", supervisorName: "Yasmine TAOUIR", surfaceM2: 50, dateStr: "13-12-2021 au 13-05-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Essai de triticale", fieldName: "La p√©pini√®re", clientName: "Dr EL HAFIDI", supervisorName: "Yasmine TAOUIR", surfaceM2: 300, dateStr: "depuis 20-12-2021", status: "EN_COURS", activityTypeLabel: "C√©r√©aliculture" },
  { title: "Essai ComSilageCorn", fieldName: "La p√©pini√®re", clientName: "Rachida Naciri", supervisorName: "Yasmine TAOUIR", surfaceM2: 25, dateStr: "25-03-22 au 23-06-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Effets d'engrais phosphat√©s sur les cultures l√©gumineuses (Soil PhorLife)", fieldName: "La p√©pini√®re", clientName: "Chtouki Mohamed", supervisorName: "Yasmine TAOUIR", surfaceM2: 20, dateStr: "04-22 au 06-22", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Effets d'engrais phosphat√©s enrichis en micronutriments sur ma√Øs (ESAFE)", fieldName: "La p√©pini√®re", clientName: "Safi Uwase", supervisorName: "Yasmine TAOUIR", surfaceM2: 50, dateStr: "28-03-22 au 30-6-22", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Fertialgues 1 (Essai pr√©liminaire)", fieldName: "La p√©pini√®re", clientName: "Mohamed El mahdi EL BOUKHARI", supervisorName: "Yassine ELBEQQAL", surfaceM2: 2, dateStr: "09-2021 au 10-2021", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "Fertialgues 2 (Effet sur stress hydrique tomate)", fieldName: "La p√©pini√®re", clientName: "Mohamed El mahdi EL BOUKHARI", supervisorName: "Yassine ELBEQQAL", surfaceM2: 30, dateStr: "10-2021 au 11-2022", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "Croissance des tomates sous stress", fieldName: "La p√©pini√®re", clientName: "Mohamed El mahdi EL BOUKHARI", supervisorName: "Yassine ELBEQQAL", surfaceM2: 35, dateStr: "10-2021 au 12-2021", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "Fertialgues3 (Effet extraits algues et acides humiques)", fieldName: "La p√©pini√®re", clientName: "Bouhia Younes", supervisorName: "Yassine ELBEQQAL", surfaceM2: 30, dateStr: "28-12-2021 au 28-02-2022", status: "FINALISE", activityTypeLabel: "Recherche Scientifique" },
  { title: "Evaluer les dates de semis du quinoa", fieldName: "La p√©pini√®re", clientName: "Nawal TAAIME", supervisorName: "Yassine ELBEQQAL", surfaceM2: 1699, dateStr: "11-2021 au 09-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Evaluer l'effet de la fertilisation NPK", fieldName: "La p√©pini√®re", clientName: "Nawal TAAIME", supervisorName: "Yassine ELBEQQAL", surfaceM2: 5809, dateStr: "12-2021 au 09-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Effet r√©siduel de l'amendement organique sur quinoa", fieldName: "La p√©pini√®re", clientName: "Nawal TAAIME", supervisorName: "Yassine ELBEQQAL", surfaceM2: 3584, dateStr: "12-2021 au 09-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Evaluation de la collection du quinoa", fieldName: "La p√©pini√®re", clientName: "Manal MHADA", supervisorName: "Yassine ELBEQQAL", surfaceM2: 2268, dateStr: "10-2021 au 07-2022", status: "EN_COURS", activityTypeLabel: "Collection et Conservation" },
  { title: "Carbon Farming (ferme)", fieldName: "La p√©pini√®re", clientName: "Mohamed Louay MAATOUGUI", supervisorName: "Yassine ELBEQQAL", surfaceM2: 20000, dateStr: "10-2018 au 04-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Effet d'applications de produits organiques", fieldName: "La p√©pini√®re", clientName: "Younes BOUHIYA", supervisorName: "Yassine ELBEQQAL", surfaceM2: 10, dateStr: "11-2021 au 03-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Plateforme collection acacia", fieldName: "La p√©pini√®re", clientName: "Mohamed Louay MAATOUGUI", supervisorName: "Yassine ELBEQQAL", surfaceM2: 4607.5, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Collection et Conservation" },
  { title: "Essai de comparaison de fertilisants azot√©s", fieldName: "La p√©pini√®re", clientName: "Manal MHADA", supervisorName: "Yassine ELBEQQAL", surfaceM2: 14, dateStr: "11-2021 au 04-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Test efficacit√© du produit Biostimulant (Projet Mycorhize)", fieldName: "La p√©pini√®re", clientName: "Imad KHATOUR", supervisorName: "Yassine ELBEQQAL", surfaceM2: 0, dateStr: "En cours au laboratoire de l'UM6P", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Essai de comparaison de compostes", fieldName: "La mine", clientName: "Haitam MOULAY", supervisorName: "Yassine ELBEQQAL", surfaceM2: 14, dateStr: "15/02/2022 au 06/2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "R√©habilitation", fieldName: "La mine", clientName: "Dontien", supervisorName: "Jelloul FNIZI", surfaceM2: 8500, dateStr: "02-2020 au 02-2024", status: "EN_COURS", activityTypeLabel: "R√©habilitation des Sols" },
  { title: "Evaluation du phosphogypse en tant que fertilisant", fieldName: "La p√©pini√®re", clientName: "Mbarka OUTBAKAT", supervisorName: "Yasmine TAOUIR", surfaceM2: 3500, dateStr: "09-2020 au 12-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Evaluation de l'effet de la dose de phosphogypse", fieldName: "La p√©pini√®re", clientName: "Mbarka OUTBAKAT", supervisorName: "Yasmine TAOUIR", surfaceM2: 150, dateStr: "09-2020 au 12-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Effet de la qualit√© du phosphogypse", fieldName: "La p√©pini√®re", clientName: "Mbarka OUTBAKAT", supervisorName: "Yasmine TAOUIR", surfaceM2: 150, dateStr: "09-2020 au 12-2023", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Test de croissance des plantes-test amendement organique", fieldName: "La p√©pini√®re", clientName: "Saida TAYIBI", supervisorName: "Yasmine TAOUIR", surfaceM2: 50, dateStr: "08/02/2022 au 08/06/2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Installation d'une plateforme des cultures biosalines", fieldName: "La p√©pini√®re", clientName: "Dr CHOKRALLAH", supervisorName: "Lahoucine AIT YAHIA", surfaceM2: 20, dateStr: "Depuis 05-2021", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Oliveraie Agro-√©cologique", fieldName: "A la ferme", clientName: "Mohamed BOULIF", supervisorName: "Jelloul FNIZI", surfaceM2: 14600, dateStr: "06/01/2021 √† l'infeni", status: "EN_COURS", activityTypeLabel: "Arboriculture" },
  { title: "Carbon Farming (mine)", fieldName: "La mine", clientName: "Mohamed Louay MAATOUGUI", supervisorName: "Jelloul FNIZI", surfaceM2: 20000, dateStr: "10-2018 au 04-2022", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "Projet introduction de la culture du goji", fieldName: "La p√©pini√®re", clientName: "Khadija NASRAOUI", supervisorName: "Jelloul FNIZI", surfaceM2: 5000, dateStr: "mois 10-2021", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },
  { title: "R√©sistance des bacs", fieldName: "La p√©pini√®re", clientName: "Adil EL BAOUCHI", supervisorName: "Jelloul FNIZI", surfaceM2: 2, dateStr: "02-2021 au 03-2021", status: "EN_COURS", activityTypeLabel: "Recherche Scientifique" },

  // --- Table 2: Production Agricole et D√©veloppement ---
  { title: "Production de poulet fermier", fieldName: "A la ferme", clientName: "AITTC", supervisorName: "Yasmine TAOUIR", surfaceM2: 0, dateStr: "Programme ferme", status: "PROGRAMME", activityTypeLabel: "Production Animale" },
  { title: "Multiplication des plantes (arboricoles, ornementales, PAM)", fieldName: "La p√©pini√®re", clientName: "AITTC", supervisorName: "Lahoucine AIT YAHIA", surfaceM2: 4000, dateStr: "Programme ferme", status: "PROGRAMME", activityTypeLabel: "Multiplication V√©g√©tale" },
  { title: "Production des semences ancestrales du cumin", fieldName: "A la p√©pini√®re", clientName: "AITTC", supervisorName: "Yasmine TAOUIR", surfaceM2: 26700, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Multiplication V√©g√©tale" },
  { title: "Production des semences des c√©r√©ales INRA", fieldName: "A la p√©pini√®re", clientName: "AITTC", supervisorName: "Yasmine TAOUIR", surfaceM2: 1000, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Multiplication V√©g√©tale" },
  { title: "Production des semences quinoa", fieldName: "A la p√©pini√®re", clientName: "AITTC", supervisorName: "Yasmine TAOUIR", surfaceM2: 1152, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Multiplication V√©g√©tale" },
  { title: "Plateforme arganier", fieldName: "A la p√©pini√®re", clientName: "AITTC", supervisorName: "Jelloul FNIZI", surfaceM2: 2600, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Arboriculture" },
  { title: "Plateforme cactus", fieldName: "A la p√©pini√®re", clientName: "AITTC", supervisorName: "Yasmine TAOUIR", surfaceM2: 10000, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Collection et Conservation" },
  { title: "Verger Olivier (jeune et √¢g√©)", fieldName: "A la ferme", clientName: "AITTC", supervisorName: "Jelloul FNIZI", surfaceM2: 11000, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Arboriculture" },
  { title: "Projet panier (Tomate, carotte, courgette...)", fieldName: "A la p√©pini√®re", clientName: "AITTC", supervisorName: "Jelloul FNIZI", surfaceM2: 1000, dateStr: "A lancer", status: "A_LANCER", activityTypeLabel: "Maraichage" },
  { title: "Semis d'orge", fieldName: "A la ferme", clientName: "AITTC", supervisorName: "Jelloul FNIZI", surfaceM2: 150000, dateStr: "A lancer", status: "A_LANCER", activityTypeLabel: "C√©r√©aliculture" },
  { title: "Production atriplex", fieldName: "A la p√©pini√®re", clientName: "AITTC", supervisorName: "Lahoucine AIT YAHIA", surfaceM2: 100, dateStr: "programme", status: "PROGRAMME", activityTypeLabel: "Cultures Fourrag√®res" },
  { title: "Production panicum", fieldName: "A la p√©pini√®re", clientName: "Lahoucine AIT YAHIA", supervisorName: "Lahoucine AIT YAHIA", surfaceM2: 50, dateStr: "programme", status: "PROGRAMME", activityTypeLabel: "Cultures Fourrag√®res" },
  { title: "Production safran, menthe, verveine", fieldName: "A la p√©pini√®re", clientName: "AITTC", supervisorName: "Yasmine TAOUIR", surfaceM2: 794, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Production de PAM" },
  { title: "Installation cl√¥ture v√©g√©tales de la ferme", fieldName: "A la ferme", clientName: "AITTC", supervisorName: "Yassine ELBEQQAL", surfaceM2: 0, dateStr: "A lancer", status: "A_LANCER", activityTypeLabel: "Ornementale et Espaces Verts" },
  { title: "Entretien des espaces verts de l'AITTC", fieldName: "A la ferme", clientName: "AITTC", supervisorName: "Yassine ELBEQQAL", surfaceM2: 10000, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Ornementale et Espaces Verts" },
  { title: "Smart Farm-OCP Agribiotech", fieldName: "A la ferme", clientName: "Smart Pharm", supervisorName: "Yasmine TAOUIR", surfaceM2: 40000, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Agriculture de Pr√©cision" },
  { title: "AgriEdge 1", fieldName: "A la ferme", clientName: "Agri Edge", supervisorName: "Yasmine TAOUIR", surfaceM2: 1727, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Agriculture de Pr√©cision" },
  { title: "AgriEdge 2", fieldName: "A la ferme", clientName: "Agri Edge", supervisorName: "Yasmine TAOUIR", surfaceM2: 50000, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "Agriculture de Pr√©cision" },
  { title: "Installation parcelles pour √©tudiants-ESSAFE", fieldName: "A la ferme", clientName: "ESAFE", supervisorName: "Yassine ELBEQQAL", surfaceM2: 2200, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "D√©veloppement et Formation" },
  { title: "Installation de la parcelle master ex√©cutive (Agriculture de pr√©cision)-ESSAFE", fieldName: "A la ferme", clientName: "ESAFE", supervisorName: "Yassine ELBEQQAL", surfaceM2: 10000, dateStr: "Programme", status: "PROGRAMME", activityTypeLabel: "D√©veloppement et Formation" },

  // --- Page 2 ---
  { title: "Projet am√©nagement et entretien des espaces verts UM6P et CCI", fieldName: "Site externe", clientName: "UM6P", supervisorName: "Yassine ELBEQQAL", surfaceM2: 0, dateStr: "A d√©velopper", status: "A_LANCER", activityTypeLabel: "Ornementale et Espaces Verts" },
  { title: "Projet am√©nagement site OCP JORF LASFAR", fieldName: "Site externe", clientName: "OCP JORF LASFAR", supervisorName: "Jelloul FNIZI", surfaceM2: 0, dateStr: "A d√©velopper", status: "A_LANCER", activityTypeLabel: "Ornementale et Espaces Verts" },
  { title: "Commercialisation huiles EMMYOR", fieldName: "A la ferme", clientName: "EMINES", supervisorName: "Yassine ELBEQQAL", surfaceM2: 2500, dateStr: "Programme", status: "FINALISE", activityTypeLabel: "Commercialisation" },
];


// =========================================================================================
// SEEDING SCRIPT
// =========================================================================================

/**
 * Parses a flexible date string from the document into a Date object.
 * @param {string} dateStr - The date string (e.g., "MM-YYYY", "DD-MM-YY").
 * @returns {Date|null} A Date object or null if parsing fails.
 */
function parseDate(dateStr) {
  if (!dateStr) return null;

  // Format: DD-MM-YY or DD/MM/YYYY
  let match = dateStr.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})$/);
  if (match) {
    const day = parseInt(match[1], 10);
    const month = parseInt(match[2], 10) - 1;
    let year = parseInt(match[3], 10);
    if (year < 100) year += 2000;
    return new Date(year, month, day);
  }

  // Format: MM-YYYY
  match = dateStr.match(/^(\d{1,2})-(\d{4})$/);
  if (match) {
    const month = parseInt(match[1], 10) - 1;
    const year = parseInt(match[2], 10);
    return new Date(year, month, 1);
  }
  
  // Format: YYYY
  match = dateStr.match(/^(\d{4})$/);
  if (match) {
      return new Date(parseInt(match[1], 10), 0, 1);
  }

  return null;
}

/**
 * Parses a date range string from the document.
 * @param {string} rangeStr - The full date string from the PDF.
 * @returns {{startDate: Date|null, endDate: Date|null}}
 */
function parseDateRange(rangeStr) {
  if (!rangeStr || typeof rangeStr !== 'string') return { startDate: null, endDate: null };

  const lowerCaseStr = rangeStr.toLowerCase();

  if (lowerCaseStr.includes('depuis') || lowerCaseStr.includes('mois')) {
    const datePart = lowerCaseStr.replace('depuis', '').replace('mois', '').trim();
    return { startDate: parseDate(datePart) || parseDate(datePart.replace(' ','-')), endDate: null };
  }

  if (lowerCaseStr.includes('√† l\'infeni')) {
    const [startPart] = lowerCaseStr.split("√† l'infeni");
    return { startDate: parseDate(startPart.trim()), endDate: null };
  }

  if (lowerCaseStr.includes('au')) {
    const [startPart, endPart] = lowerCaseStr.split('au').map(s => s.trim());
    return { startDate: parseDate(startPart), endDate: parseDate(endPart) };
  }

  // If no range keyword, assume it's just a start date
  const singleDate = parseDate(lowerCaseStr);
  if(singleDate) return { startDate: singleDate, endDate: null };

  return { startDate: null, endDate: null };
}

async function seed() {
  try {
    console.log('üå± Starting database seeding based on F.75 document...');

    // Clear existing data in the correct order to avoid foreign key conflicts
    console.log('üßπ Clearing existing data...');
    await prisma.project.deleteMany();
    await prisma.reservation.deleteMany();
    await prisma.priceOffer.deleteMany();
    await prisma.serviceOrder.deleteMany();
    await prisma.inventoryItem.deleteMany();
    await prisma.user.deleteMany();
    await prisma.field.deleteMany();
    await prisma.activityType.deleteMany();
    await prisma.entity.deleteMany();

    // 1. Create Entities
    console.log('üè¢ Creating entities...');
    const createdEntities = {};
    for (const entity of entities) {
      const newEntity = await prisma.entity.create({ data: entity });
      createdEntities[entity.name] = newEntity;
    }
    console.log(`   ...${Object.keys(createdEntities).length} entities created.`);

    // 2. Create Activity Types
    console.log('üè∑Ô∏è Creating activity types...');
    const createdActivityTypes = {};
    for (const type of activityTypes) {
      const newType = await prisma.activityType.create({ data: type });
      createdActivityTypes[type.label] = newType;
    }
    console.log(`   ...${Object.keys(createdActivityTypes).length} activity types created.`);

    // 3. Calculate Field Surface and Create Fields
    console.log('üåæ Calculating surface usage and creating fields...');
    const fieldUsage = {};
    for (const field of fields) {
        fieldUsage[field.name] = 0;
    }
    for (const project of projects) {
        if(fieldUsage.hasOwnProperty(project.fieldName)) {
            fieldUsage[project.fieldName] += project.surfaceM2;
        }
    }
    const createdFields = {};
    for (const field of fields) {
      const totalSurfaceM2 = fieldUsage[field.name];
      const newField = await prisma.field.create({
        data: {
          name: field.name,
          location: field.location,
          // Set total surface to used surface + 20% buffer, and free surface to that buffer.
          totalSurfaceM2: Math.ceil(totalSurfaceM2 * 1.2),
          freeSurfaceM2: Math.ceil(totalSurfaceM2 * 0.2),
        },
      });
      createdFields[field.name] = newField;
    }
     console.log(`   ...${Object.keys(createdFields).length} fields created.`);

    // 4. Create Users (including a default Admin)
    console.log('üë• Creating users...');
    // Admin User
    const adminPasswordHash = await bcrypt.hash(process.env.ADMIN_PASSWORD || 'admin123', 12);
    await prisma.user.create({
      data: {
        email: process.env.ADMIN_EMAIL || 'admin@aittc.ma',
        passwordHash: adminPasswordHash,
        name: process.env.ADMIN_NAME || 'System Administrator',
        role: 'ADMIN',
        isVerified: true,
      },
    });

    // Users from the document
    const createdUsers = {};
    const defaultPasswordHash = await bcrypt.hash('password123', 12);
    for (const user of users) {
      if (user.inconnu_client_1) continue; // Skip specific placeholders if any
      if (user.inconnu_client_2) continue; // Skip specific placeholders if any
      const entityId = createdEntities[user.entityName]?.id;
      const newUser = await prisma.user.create({
        data: {
          email: user.email,
          passwordHash: defaultPasswordHash,
          name: user.name,
          role: user.role,
          entityId,
          isVerified: true,
        },
      });
      createdUsers[user.name] = newUser;
    }
    // Create dedicated users for entity clients if not already present
    const entityClientNames = ['AITTC', 'Smart Pharm', 'Agri Edge', 'ESAFE', 'UM6P', 'OCP JORF LASFAR', 'EMINES'];
    for (const entityName of entityClientNames) {
      if (!createdUsers[entityName]) {
        const entityId = createdEntities[entityName]?.id;
        const newUser = await prisma.user.create({
          data: {
            email: `${entityName.toLowerCase().replace(/[^a-z0-9]/g, '')}@entityclient.ma`,
            passwordHash: defaultPasswordHash,
            name: entityName,
            role: 'CLIENT',
            entityId,
            isVerified: true,
          },
        });
        createdUsers[entityName] = newUser;
      }
    }
    // Find a default supervisor and client for fallback
    const defaultSupervisor = Object.values(createdUsers).find(u => u.role === 'SUPERVISOR');
    const defaultClient = Object.values(createdUsers).find(u => u.role === 'CLIENT');

    console.log(`   ...${Object.keys(createdUsers).length + 1} users created.`);


    // 5. Create Projects
    console.log('üìã Creating projects...');
    let projectCount = 0;
    for (const projectData of projects) {
      const { startDate, endDate } = parseDateRange(projectData.dateStr);
      // Look up foreign keys robustly
      const field = createdFields[projectData.fieldName] || Object.values(createdFields)[0];
      const client = createdUsers[projectData.clientName] || createdUsers[projectData.clientName?.trim()] || defaultClient;
      const supervisor = createdUsers[projectData.supervisorName] || createdUsers[projectData.supervisorName?.trim()] || defaultSupervisor;
      const activityType = createdActivityTypes[projectData.activityTypeLabel];
      // Map status from PDF string to schema enum
      let statusEnum = 'A_LANCER';
      if (projectData.status.toLowerCase().includes('finalis√©')) statusEnum = 'FINALISE';
      if (projectData.status.toLowerCase().includes('en cours')) statusEnum = 'EN_COURS';
      if (projectData.status.toLowerCase().includes('programme')) statusEnum = 'PROGRAMME';
      if (projectData.status.toLowerCase().includes('lancer')) statusEnum = 'A_LANCER';
      await prisma.project.create({
        data: {
          title: projectData.title,
          surfaceM2: projectData.surfaceM2,
          status: statusEnum,
          startDate: startDate || new Date(),
          endDate,
          fieldId: field.id,
          clientId: client.id,
          supervisorId: supervisor.id,
          activityTypeId: activityType?.id,
        },
      });
      projectCount++;
    }
    console.log(`   ...${projectCount} projects created.`);


    console.log('‚úÖ Database seeding completed successfully!');
    
  } catch (error) {
    console.error('‚ùå Error during seeding:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

seed();

# ==== src/context/AuthContext.tsx ====

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import api from '../services/api';

interface User {
  id: string;
  name: string;
  email: string;
  role: 'ADMIN' | 'SUPERVISOR' | 'CLIENT';
  isVerified: boolean;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  register: (data: RegisterData) => Promise<void>;
  token: string | null;
}

interface RegisterData {
  name: string;
  email: string;
  password: string;
  entityId?: string;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(localStorage.getItem('token'));
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchProfile = async () => {
      if (token) {
        try {
          const res = await api.get('/auth/profile');
          setUser(res.data);
        } catch (err) {
          setUser(null);
          setToken(null);
          localStorage.removeItem('token');
        }
      }
      setLoading(false);
    };
    fetchProfile();
  }, [token]);

  const login = async (email: string, password: string) => {
    setLoading(true);
    try {
      const res = await api.post('/auth/login', { email, password });
      setToken(res.data.token);
      localStorage.setItem('token', res.data.token);
      const profile = await api.get('/auth/profile');
      setUser(profile.data);
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
  };

  const register = async (data: RegisterData) => {
    setLoading(true);
    try {
      await api.post('/auth/register', data);
    } finally {
      setLoading(false);
    }
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout, register, token }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}; 

# ==== src/utils/pdfGenerator.js ====

const PDFDocument = require('pdfkit');

// Generate PDF for service order
const generateServiceOrderPDF = async (serviceOrder) => {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument();
    const chunks = [];
    
    doc.on('data', chunk => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);
    
    // Add content to PDF
    doc.fontSize(18).text('Service Order', { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text(`Object: ${serviceOrder.objet}`);
    doc.text(`Market Number: ${serviceOrder.marketNumber || 'N/A'}`);
    doc.text(`BC Number: ${serviceOrder.bcNumber || 'N/A'}`);
    doc.text(`Start Date: ${serviceOrder.startDate.toLocaleDateString()}`);
    doc.text(`Client Representative: ${serviceOrder.clientRep}`);
    doc.text(`Supplier: ${serviceOrder.supplier}`);
    doc.text(`Status: ${serviceOrder.status}`);
    
    doc.end();
  });
};

// Generate PDF for price offer
const generatePriceOfferPDF = async (priceOffer) => {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument();
    const chunks = [];
    
    doc.on('data', chunk => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);
    
    // Add content to PDF
    doc.fontSize(18).text('Price Offer', { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text(`Destinataire: ${priceOffer.destinataire}`);
    doc.text(`Demandeur: ${priceOffer.demandeur}`);
    doc.text(`Item: ${priceOffer.itemDesignation}`);
    doc.text(`Quantity: ${priceOffer.quantity} ${priceOffer.unit}`);
    doc.text(`Status: ${priceOffer.status}`);
    
    doc.end();
  });
};

module.exports = {
  generateServiceOrderPDF,
  generatePriceOfferPDF
}; 

# ==== src/utils/email.js ====

const nodemailer = require('nodemailer');

// Create transporter
const createTransporter = () => {
  return nodemailer.createTransporter({
    host: process.env.EMAIL_HOST,
    port: process.env.EMAIL_PORT,
    secure: process.env.EMAIL_PORT === '465', // true for 465, false for other ports
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS
    }
  });
};

// Send verification email
const sendVerificationEmail = async (email, token) => {
  const transporter = createTransporter();
  
  const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${token}`;
  
  const mailOptions = {
    from: process.env.EMAIL_FROM,
    to: email,
    subject: 'AITTC Farm Management - Email Verification',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background-color: #2c5aa0; color: white; padding: 20px; text-align: center;">
          <h1>AITTC Farm Management System</h1>
        </div>
        
        <div style="padding: 20px; background-color: #f9f9f9;">
          <h2>Welcome to AITTC Farm Management!</h2>
          
          <p>Thank you for registering with the AITTC Experimental Farm Management System. To complete your registration, please verify your email address by clicking the button below:</p>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${verificationUrl}" 
               style="background-color: #2c5aa0; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block;">
              Verify Email Address
            </a>
          </div>
          
          <p>If the button doesn't work, you can copy and paste this link into your browser:</p>
          <p style="word-break: break-all; color: #666;">${verificationUrl}</p>
          
          <p>This verification link will expire in 24 hours.</p>
          
          <p>If you didn't create an account with us, please ignore this email.</p>
        </div>
        
        <div style="background-color: #333; color: white; padding: 15px; text-align: center; font-size: 12px;">
          <p>AITTC Experimental Farm Management System</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </div>
    `
  };

  try {
    await transporter.sendMail(mailOptions);
    console.log(`Verification email sent to ${email}`);
  } catch (error) {
    console.error('Error sending verification email:', error);
    throw error;
  }
};

// Send password reset email
const sendPasswordResetEmail = async (email, token) => {
  const transporter = createTransporter();
  
  const resetUrl = `${process.env.FRONTEND_URL}/reset-password/${token}`;
  
  const mailOptions = {
    from: process.env.EMAIL_FROM,
    to: email,
    subject: 'AITTC Farm Management - Password Reset',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background-color: #2c5aa0; color: white; padding: 20px; text-align: center;">
          <h1>AITTC Farm Management System</h1>
        </div>
        
        <div style="padding: 20px; background-color: #f9f9f9;">
          <h2>Password Reset Request</h2>
          
          <p>You have requested to reset your password for the AITTC Farm Management System. Click the button below to create a new password:</p>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${resetUrl}" 
               style="background-color: #2c5aa0; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block;">
              Reset Password
            </a>
          </div>
          
          <p>If the button doesn't work, you can copy and paste this link into your browser:</p>
          <p style="word-break: break-all; color: #666;">${resetUrl}</p>
          
          <p>This reset link will expire in 24 hours.</p>
          
          <p>If you didn't request a password reset, please ignore this email. Your password will remain unchanged.</p>
        </div>
        
        <div style="background-color: #333; color: white; padding: 15px; text-align: center; font-size: 12px;">
          <p>AITTC Experimental Farm Management System</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </div>
    `
  };

  try {
    await transporter.sendMail(mailOptions);
    console.log(`Password reset email sent to ${email}`);
  } catch (error) {
    console.error('Error sending password reset email:', error);
    throw error;
  }
};

// Send notification email for reservation status change
const sendReservationStatusEmail = async (email, reservation, status, projectTitle) => {
  const transporter = createTransporter();
  
  const statusText = status === 'APPROVED' ? 'approved' : 'rejected';
  const statusColor = status === 'APPROVED' ? '#28a745' : '#dc3545';
  
  const mailOptions = {
    from: process.env.EMAIL_FROM,
    to: email,
    subject: `AITTC Farm Management - Reservation ${statusText.charAt(0).toUpperCase() + statusText.slice(1)}`,
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background-color: #2c5aa0; color: white; padding: 20px; text-align: center;">
          <h1>AITTC Farm Management System</h1>
        </div>
        
        <div style="padding: 20px; background-color: #f9f9f9;">
          <h2>Reservation Status Update</h2>
          
          <p>Your field reservation request has been <strong style="color: ${statusColor};">${statusText}</strong>.</p>
          
          <div style="background-color: white; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <h3>Reservation Details:</h3>
            <p><strong>Project:</strong> ${projectTitle}</p>
            <p><strong>Surface Area:</strong> ${reservation.surfaceM2Requested} m¬≤</p>
            <p><strong>Start Date:</strong> ${new Date(reservation.startRequested).toLocaleDateString()}</p>
            <p><strong>End Date:</strong> ${new Date(reservation.endRequested).toLocaleDateString()}</p>
            <p><strong>Status:</strong> <span style="color: ${statusColor}; font-weight: bold;">${status}</span></p>
          </div>
          
          ${status === 'APPROVED' ? `
            <p>Your project has been approved and assigned to a supervisor. You will receive further updates on your project progress.</p>
          ` : `
            <p>If you have any questions about this decision, please contact the farm administration.</p>
          `}
        </div>
        
        <div style="background-color: #333; color: white; padding: 15px; text-align: center; font-size: 12px;">
          <p>AITTC Experimental Farm Management System</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </div>
    `
  };

  try {
    await transporter.sendMail(mailOptions);
    console.log(`Reservation status email sent to ${email}`);
  } catch (error) {
    console.error('Error sending reservation status email:', error);
    throw error;
  }
};

// Send notification email for project assignment
const sendProjectAssignmentEmail = async (email, project, supervisorName) => {
  const transporter = createTransporter();
  
  const mailOptions = {
    from: process.env.EMAIL_FROM,
    to: email,
    subject: 'AITTC Farm Management - Project Assignment',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background-color: #2c5aa0; color: white; padding: 20px; text-align: center;">
          <h1>AITTC Farm Management System</h1>
        </div>
        
        <div style="padding: 20px; background-color: #f9f9f9;">
          <h2>Project Assignment Notification</h2>
          
          <p>You have been assigned as a supervisor for a new project at the AITTC Experimental Farm.</p>
          
          <div style="background-color: white; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <h3>Project Details:</h3>
            <p><strong>Project Title:</strong> ${project.title}</p>
            <p><strong>Surface Area:</strong> ${project.surfaceM2} m¬≤</p>
            <p><strong>Start Date:</strong> ${new Date(project.startDate).toLocaleDateString()}</p>
            <p><strong>End Date:</strong> ${project.endDate ? new Date(project.endDate).toLocaleDateString() : 'TBD'}</p>
            <p><strong>Status:</strong> ${project.status}</p>
          </div>
          
          <p>Please log in to the system to view project details and provide progress updates.</p>
        </div>
        
        <div style="background-color: #333; color: white; padding: 15px; text-align: center; font-size: 12px;">
          <p>AITTC Experimental Farm Management System</p>
          <p>This is an automated message, please do not reply.</p>
        </div>
      </div>
    `
  };

  try {
    await transporter.sendMail(mailOptions);
    console.log(`Project assignment email sent to ${email}`);
  } catch (error) {
    console.error('Error sending project assignment email:', error);
    throw error;
  }
};

module.exports = {
  sendVerificationEmail,
  sendPasswordResetEmail,
  sendReservationStatusEmail,
  sendProjectAssignmentEmail
}; 

# ==== src/pages/Login.tsx ====

import React from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { TextField, Button, Box, Typography, CircularProgress } from '@mui/material';
import { useAuth } from '../context/AuthContext';

const schema = yup.object().shape({
  email: yup.string().email('Invalid email').required('Email is required'),
  password: yup.string().required('Password is required'),
});

type LoginFormInputs = {
  email: string;
  password: string;
};

const Login: React.FC = () => {
  const { login, loading } = useAuth();
  const { register, handleSubmit, formState: { errors }, setError } = useForm<LoginFormInputs>({
    resolver: yupResolver(schema),
  });

  const onSubmit = async (data: LoginFormInputs) => {
    try {
      await login(data.email, data.password);
      // Redirect handled by router
    } catch (err: any) {
      setError('email', { message: 'Invalid credentials' });
    }
  };

  return (
    <Box maxWidth={400} mx="auto" mt={8} p={3} boxShadow={2} borderRadius={2}>
      <Typography variant="h5" mb={2} align="center">Login</Typography>
      <form onSubmit={handleSubmit(onSubmit)}>
        <TextField
          label="Email"
          fullWidth
          margin="normal"
          {...register('email')}
          error={!!errors.email}
          helperText={errors.email?.message}
        />
        <TextField
          label="Password"
          type="password"
          fullWidth
          margin="normal"
          {...register('password')}
          error={!!errors.password}
          helperText={errors.password?.message}
        />
        <Box mt={2} display="flex" justifyContent="center">
          <Button type="submit" variant="contained" color="primary" disabled={loading} fullWidth>
            {loading ? <CircularProgress size={24} /> : 'Login'}
          </Button>
        </Box>
      </form>
    </Box>
  );
};

export default Login; 

# ==== src/routes/ProtectedRoute.tsx ====

import React from 'react';
import { RouteProps, Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

interface ProtectedRouteProps extends RouteProps {
  allowedRoles?: Array<'ADMIN' | 'SUPERVISOR' | 'CLIENT'>;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ allowedRoles }) => {
  const { user, loading } = useAuth();

  if (loading) return <div>Loading...</div>;
  if (!user) return <Navigate to="/login" replace />;
  if (allowedRoles && !allowedRoles.includes(user.role)) {
    return <Navigate to="/unauthorized" replace />;
  }
  return <Outlet />;
};

export default ProtectedRoute; 

# ==== src/routes/auth.js ====

const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { v4: uuidv4 } = require('uuid');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { sendVerificationEmail, sendPasswordResetEmail } = require('../utils/email');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

// Validation schemas
const registerValidation = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }),
  body('name').trim().isLength({ min: 2 }),
  body('entityId').optional().isUUID()
];

const loginValidation = [
  body('email').isEmail().normalizeEmail(),
  body('password').notEmpty()
];

const resetPasswordValidation = [
  body('email').isEmail().normalizeEmail()
];

const newPasswordValidation = [
  body('token').notEmpty(),
  body('password').isLength({ min: 6 })
];

// Register new user
router.post('/register', registerValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { email, password, name, entityId } = req.body;

    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email }
    });

    if (existingUser) {
      return res.status(409).json({
        error: 'User Already Exists',
        message: 'A user with this email already exists'
      });
    }

    // Hash password
    const saltRounds = 12;
    const passwordHash = await bcrypt.hash(password, saltRounds);

    // Generate verification token
    const verificationToken = uuidv4();

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        name,
        entityId,
        verificationToken,
        role: 'CLIENT' // Default role for new registrations
      },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        isVerified: true,
        createdAt: true
      }
    });

    // Send verification email
    try {
      await sendVerificationEmail(user.email, verificationToken);
    } catch (emailError) {
      console.error('Failed to send verification email:', emailError);
      // Don't fail the registration if email fails
    }

    res.status(201).json({
      message: 'User registered successfully. Please check your email for verification.',
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        isVerified: user.isVerified
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      error: 'Registration Failed',
      message: 'Failed to register user'
    });
  }
});

// Login user
router.post('/login', loginValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { email, password } = req.body;

    // Find user
    const user = await prisma.user.findUnique({
      where: { email },
      include: {
        entity: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });

    if (!user) {
      return res.status(401).json({
        error: 'Invalid Credentials',
        message: 'Invalid email or password'
      });
    }

    // Check password
    const isValidPassword = await bcrypt.compare(password, user.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({
        error: 'Invalid Credentials',
        message: 'Invalid email or password'
      });
    }

    // Check if user is verified
    if (!user.isVerified) {
      return res.status(403).json({
        error: 'Account Not Verified',
        message: 'Please verify your email address before logging in'
      });
    }

    // Generate JWT token
    const token = jwt.sign(
      { 
        userId: user.id,
        email: user.email,
        role: user.role
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || '7d' }
    );

    res.json({
      message: 'Login successful',
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        entity: user.entity
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      error: 'Login Failed',
      message: 'Failed to authenticate user'
    });
  }
});

// Verify email
router.get('/verify/:token', async (req, res) => {
  try {
    const { token } = req.params;

    const user = await prisma.user.findFirst({
      where: { verificationToken: token }
    });

    if (!user) {
      return res.status(400).json({
        error: 'Invalid Token',
        message: 'Invalid or expired verification token'
      });
    }

    // Update user as verified
    await prisma.user.update({
      where: { id: user.id },
      data: {
        isVerified: true,
        verificationToken: null
      }
    });

    res.json({
      message: 'Email verified successfully. You can now log in.'
    });
  } catch (error) {
    console.error('Email verification error:', error);
    res.status(500).json({
      error: 'Verification Failed',
      message: 'Failed to verify email'
    });
  }
});

// Request password reset
router.post('/forgot-password', resetPasswordValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { email } = req.body;

    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      // Don't reveal if user exists or not
      return res.json({
        message: 'If an account with this email exists, a password reset link has been sent.'
      });
    }

    // Generate reset token
    const resetToken = uuidv4();
    const resetTokenExpiry = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    // Update user with reset token
    await prisma.user.update({
      where: { id: user.id },
      data: {
        resetToken,
        resetTokenExpiry
      }
    });

    // Send reset email
    try {
      await sendPasswordResetEmail(user.email, resetToken);
    } catch (emailError) {
      console.error('Failed to send password reset email:', emailError);
      return res.status(500).json({
        error: 'Email Send Failed',
        message: 'Failed to send password reset email'
      });
    }

    res.json({
      message: 'If an account with this email exists, a password reset link has been sent.'
    });
  } catch (error) {
    console.error('Password reset request error:', error);
    res.status(500).json({
      error: 'Password Reset Failed',
      message: 'Failed to process password reset request'
    });
  }
});

// Reset password with token
router.post('/reset-password', newPasswordValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { token, password } = req.body;

    const user = await prisma.user.findFirst({
      where: {
        resetToken: token,
        resetTokenExpiry: {
          gt: new Date()
        }
      }
    });

    if (!user) {
      return res.status(400).json({
        error: 'Invalid Token',
        message: 'Invalid or expired reset token'
      });
    }

    // Hash new password
    const saltRounds = 12;
    const passwordHash = await bcrypt.hash(password, saltRounds);

    // Update user password and clear reset token
    await prisma.user.update({
      where: { id: user.id },
      data: {
        passwordHash,
        resetToken: null,
        resetTokenExpiry: null
      }
    });

    res.json({
      message: 'Password reset successfully. You can now log in with your new password.'
    });
  } catch (error) {
    console.error('Password reset error:', error);
    res.status(500).json({
      error: 'Password Reset Failed',
      message: 'Failed to reset password'
    });
  }
});

// Get current user profile
router.get('/profile', authenticateToken, async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.user.id },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        isVerified: true
      }
    });
    if (!user) return res.status(404).json({ error: 'User not found' });
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch profile' });
  }
});

module.exports = router; 

# ==== src/routes/exports.js ====

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { authenticateToken, requireRole } = require('../middleware/auth');
const { createObjectCsvWriter } = require('csv-writer');
const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

const router = express.Router();
const prisma = new PrismaClient();

// Helper function to generate CSV
const generateCSV = async (data, headers, filename) => {
  const csvWriter = createObjectCsvWriter({
    path: filename,
    header: headers
  });
  
  await csvWriter.writeRecords(data);
  return filename;
};

// Helper function to generate PDF
const generatePDF = (data, title, filename) => {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument();
    const stream = fs.createWriteStream(filename);
    
    doc.pipe(stream);
    
    // Add title
    doc.fontSize(18).text(title, { align: 'center' });
    doc.moveDown();
    
    // Add data
    if (Array.isArray(data)) {
      data.forEach((item, index) => {
        doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(item)}`);
        doc.moveDown(0.5);
      });
    } else {
      doc.fontSize(12).text(JSON.stringify(data, null, 2));
    }
    
    doc.end();
    
    stream.on('finish', () => resolve(filename));
    stream.on('error', reject);
  });
};

// Export fields data
router.get('/fields', authenticateToken, requireRole(['ADMIN']), async (req, res) => {
  try {
    const { format = 'csv' } = req.query;
    
    const fields = await prisma.field.findMany({
      include: {
        projects: {
          include: {
            client: { select: { name: true, email: true } },
            supervisor: { select: { name: true, email: true } }
          }
        }
      }
    });

    const filename = `fields_export_${Date.now()}.${format}`;
    const filepath = path.join(process.env.UPLOAD_PATH || './uploads', filename);

    if (format === 'csv') {
      const headers = [
        { id: 'id', title: 'ID' },
        { id: 'name', title: 'Name' },
        { id: 'location', title: 'Location' },
        { id: 'totalSurfaceM2', title: 'Total Surface (m¬≤)' },
        { id: 'freeSurfaceM2', title: 'Free Surface (m¬≤)' },
        { id: 'status', title: 'Status' },
        { id: 'notes', title: 'Notes' },
        { id: 'createdAt', title: 'Created At' }
      ];

      const csvData = fields.map(field => ({
        id: field.id,
        name: field.name,
        location: field.location,
        totalSurfaceM2: field.totalSurfaceM2,
        freeSurfaceM2: field.freeSurfaceM2,
        status: field.status,
        notes: field.notes || '',
        createdAt: field.createdAt.toISOString()
      }));

      await generateCSV(csvData, headers, filepath);
    } else if (format === 'pdf') {
      await generatePDF(fields, 'Fields Export', filepath);
    }

    res.download(filepath, filename, (err) => {
      if (err) {
        console.error('Download error:', err);
      }
      // Clean up file after download
      fs.unlink(filepath, (unlinkErr) => {
        if (unlinkErr) console.error('File cleanup error:', unlinkErr);
      });
    });
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Failed to export fields data' });
  }
});

// Export projects data
router.get('/projects', authenticateToken, requireRole(['ADMIN', 'SUPERVISOR']), async (req, res) => {
  try {
    const { format = 'csv', status, startDate, endDate } = req.query;
    const { role, userId } = req.user;

    // Build filter conditions
    const where = {};
    if (status) where.status = status;
    if (startDate || endDate) {
      where.startDate = {};
      if (startDate) where.startDate.gte = new Date(startDate);
      if (endDate) where.startDate.lte = new Date(endDate);
    }
    
    // Supervisors can only see their assigned projects
    if (role === 'SUPERVISOR') {
      where.supervisorId = userId;
    }

    const projects = await prisma.project.findMany({
      where,
      include: {
        field: true,
        client: { select: { name: true, email: true } },
        supervisor: { select: { name: true, email: true } },
        activityType: true
      }
    });

    const filename = `projects_export_${Date.now()}.${format}`;
    const filepath = path.join(process.env.UPLOAD_PATH || './uploads', filename);

    if (format === 'csv') {
      const headers = [
        { id: 'id', title: 'ID' },
        { id: 'title', title: 'Title' },
        { id: 'fieldName', title: 'Field' },
        { id: 'clientName', title: 'Client' },
        { id: 'supervisorName', title: 'Supervisor' },
        { id: 'activityType', title: 'Activity Type' },
        { id: 'surfaceM2', title: 'Surface (m¬≤)' },
        { id: 'startDate', title: 'Start Date' },
        { id: 'endDate', title: 'End Date' },
        { id: 'status', title: 'Status' },
        { id: 'progressNotes', title: 'Progress Notes' }
      ];

      const csvData = projects.map(project => ({
        id: project.id,
        title: project.title,
        fieldName: project.field.name,
        clientName: project.client.name,
        supervisorName: project.supervisor.name,
        activityType: project.activityType?.label || '',
        surfaceM2: project.surfaceM2,
        startDate: project.startDate.toISOString(),
        endDate: project.endDate?.toISOString() || '',
        status: project.status,
        progressNotes: project.progressNotes || ''
      }));

      await generateCSV(csvData, headers, filepath);
    } else if (format === 'pdf') {
      await generatePDF(projects, 'Projects Export', filepath);
    }

    res.download(filepath, filename, (err) => {
      if (err) {
        console.error('Download error:', err);
      }
      fs.unlink(filepath, (unlinkErr) => {
        if (unlinkErr) console.error('File cleanup error:', unlinkErr);
      });
    });
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Failed to export projects data' });
  }
});

// Export inventory data
router.get('/inventory', authenticateToken, requireRole(['ADMIN']), async (req, res) => {
  try {
    const { format = 'csv', condition, family } = req.query;
    
    const where = {};
    if (condition) where.condition = condition;
    if (family) where.family = { contains: family, mode: 'insensitive' };

    const inventory = await prisma.inventoryItem.findMany({ where });

    const filename = `inventory_export_${Date.now()}.${format}`;
    const filepath = path.join(process.env.UPLOAD_PATH || './uploads', filename);

    if (format === 'csv') {
      const headers = [
        { id: 'id', title: 'ID' },
        { id: 'owner', title: 'Owner' },
        { id: 'family', title: 'Family' },
        { id: 'subFamily', title: 'Sub Family' },
        { id: 'designation', title: 'Designation' },
        { id: 'stockQty', title: 'Stock Quantity' },
        { id: 'unit', title: 'Unit' },
        { id: 'condition', title: 'Condition' },
        { id: 'location', title: 'Location' },
        { id: 'lastChecked', title: 'Last Checked' }
      ];

      const csvData = inventory.map(item => ({
        id: item.id,
        owner: item.owner,
        family: item.family,
        subFamily: item.subFamily || '',
        designation: item.designation,
        stockQty: item.stockQty,
        unit: item.unit,
        condition: item.condition,
        location: item.location,
        lastChecked: item.lastChecked.toISOString()
      }));

      await generateCSV(csvData, headers, filepath);
    } else if (format === 'pdf') {
      await generatePDF(inventory, 'Inventory Export', filepath);
    }

    res.download(filepath, filename, (err) => {
      if (err) {
        console.error('Download error:', err);
      }
      fs.unlink(filepath, (unlinkErr) => {
        if (unlinkErr) console.error('File cleanup error:', unlinkErr);
      });
    });
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Failed to export inventory data' });
  }
});

// Export reservations data
router.get('/reservations', authenticateToken, requireRole(['ADMIN']), async (req, res) => {
  try {
    const { format = 'csv', status, startDate, endDate } = req.query;
    
    const where = {};
    if (status) where.status = status;
    if (startDate || endDate) {
      where.startRequested = {};
      if (startDate) where.startRequested.gte = new Date(startDate);
      if (endDate) where.startRequested.lte = new Date(endDate);
    }

    const reservations = await prisma.reservation.findMany({
      where,
      include: {
        client: { select: { name: true, email: true } },
        field: true,
        supervisor: { select: { name: true, email: true } }
      }
    });

    const filename = `reservations_export_${Date.now()}.${format}`;
    const filepath = path.join(process.env.UPLOAD_PATH || './uploads', filename);

    if (format === 'csv') {
      const headers = [
        { id: 'id', title: 'ID' },
        { id: 'clientName', title: 'Client' },
        { id: 'fieldName', title: 'Field' },
        { id: 'surfaceM2Requested', title: 'Surface Requested (m¬≤)' },
        { id: 'startRequested', title: 'Start Date Requested' },
        { id: 'endRequested', title: 'End Date Requested' },
        { id: 'status', title: 'Status' },
        { id: 'supervisorName', title: 'Supervisor' },
        { id: 'decisionDate', title: 'Decision Date' },
        { id: 'createdAt', title: 'Created At' }
      ];

      const csvData = reservations.map(reservation => ({
        id: reservation.id,
        clientName: reservation.client.name,
        fieldName: reservation.field.name,
        surfaceM2Requested: reservation.surfaceM2Requested,
        startRequested: reservation.startRequested.toISOString(),
        endRequested: reservation.endRequested.toISOString(),
        status: reservation.status,
        supervisorName: reservation.supervisor?.name || '',
        decisionDate: reservation.decisionDate?.toISOString() || '',
        createdAt: reservation.createdAt.toISOString()
      }));

      await generateCSV(csvData, headers, filepath);
    } else if (format === 'pdf') {
      await generatePDF(reservations, 'Reservations Export', filepath);
    }

    res.download(filepath, filename, (err) => {
      if (err) {
        console.error('Download error:', err);
      }
      fs.unlink(filepath, (unlinkErr) => {
        if (unlinkErr) console.error('File cleanup error:', unlinkErr);
      });
    });
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Failed to export reservations data' });
  }
});

// Export users data
router.get('/users', authenticateToken, requireRole(['ADMIN']), async (req, res) => {
  try {
    const { format = 'csv', role } = req.query;
    
    const where = {};
    if (role) where.role = role;

    const users = await prisma.user.findMany({
      where,
      include: {
        entity: true
      }
    });

    const filename = `users_export_${Date.now()}.${format}`;
    const filepath = path.join(process.env.UPLOAD_PATH || './uploads', filename);

    if (format === 'csv') {
      const headers = [
        { id: 'id', title: 'ID' },
        { id: 'name', title: 'Name' },
        { id: 'email', title: 'Email' },
        { id: 'role', title: 'Role' },
        { id: 'entityName', title: 'Entity' },
        { id: 'isVerified', title: 'Verified' },
        { id: 'createdAt', title: 'Created At' }
      ];

      const csvData = users.map(user => ({
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
        entityName: user.entity?.name || '',
        isVerified: user.isVerified,
        createdAt: user.createdAt.toISOString()
      }));

      await generateCSV(csvData, headers, filepath);
    } else if (format === 'pdf') {
      await generatePDF(users, 'Users Export', filepath);
    }

    res.download(filepath, filename, (err) => {
      if (err) {
        console.error('Download error:', err);
      }
      fs.unlink(filepath, (unlinkErr) => {
        if (unlinkErr) console.error('File cleanup error:', unlinkErr);
      });
    });
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Failed to export users data' });
  }
});

// Export comprehensive report
router.get('/comprehensive-report', authenticateToken, requireRole(['ADMIN']), async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    
    const dateFilter = {};
    if (startDate || endDate) {
      if (startDate) dateFilter.gte = new Date(startDate);
      if (endDate) dateFilter.lte = new Date(endDate);
    }

    const [fields, projects, reservations, inventory, users] = await Promise.all([
      prisma.field.findMany(),
      prisma.project.findMany({
        where: { createdAt: dateFilter },
        include: {
          field: true,
          client: { select: { name: true } },
          supervisor: { select: { name: true } }
        }
      }),
      prisma.reservation.findMany({
        where: { createdAt: dateFilter },
        include: {
          client: { select: { name: true } },
          field: true
        }
      }),
      prisma.inventoryItem.findMany(),
      prisma.user.findMany({
        include: { entity: true }
      })
    ]);

    const report = {
      summary: {
        totalFields: fields.length,
        totalProjects: projects.length,
        totalReservations: reservations.length,
        totalInventoryItems: inventory.length,
        totalUsers: users.length,
        activeFields: fields.filter(f => f.status === 'ACTIVE').length,
        completedProjects: projects.filter(p => p.status === 'FINALISE').length,
        pendingReservations: reservations.filter(r => r.status === 'PENDING').length
      },
      fields,
      projects,
      reservations,
      inventory,
      users
    };

    const filename = `comprehensive_report_${Date.now()}.pdf`;
    const filepath = path.join(process.env.UPLOAD_PATH || './uploads', filename);

    await generatePDF(report, 'Comprehensive Farm Management Report', filepath);

    res.download(filepath, filename, (err) => {
      if (err) {
        console.error('Download error:', err);
      }
      fs.unlink(filepath, (unlinkErr) => {
        if (unlinkErr) console.error('File cleanup error:', unlinkErr);
      });
    });
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Failed to export comprehensive report' });
  }
});

module.exports = router; 

# ==== src/routes/users.js ====

const express = require('express');
const bcrypt = require('bcryptjs');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { authenticateToken, requireRole, requireOwnershipOrAdmin } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

// Validation schemas
const createUserValidation = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 }),
  body('name').trim().isLength({ min: 2 }),
  body('role').isIn(['ADMIN', 'SUPERVISOR', 'CLIENT']),
  body('entityId').optional().isUUID()
];

const updateUserValidation = [
  body('email').optional().isEmail().normalizeEmail(),
  body('name').optional().trim().isLength({ min: 2 }),
  body('role').optional().isIn(['ADMIN', 'SUPERVISOR', 'CLIENT']),
  body('entityId').optional().isUUID()
];

const changePasswordValidation = [
  body('currentPassword').notEmpty(),
  body('newPassword').isLength({ min: 6 })
];

// Get all users (Admin only)
router.get('/', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  try {
    const { page = 1, limit = 10, role, search, entityId } = req.query;
    const skip = (page - 1) * limit;

    let whereClause = {};

    // Filter by role if provided
    if (role) {
      whereClause.role = role;
    }

    // Filter by entity if provided
    if (entityId) {
      whereClause.entityId = entityId;
    }

    // Search functionality
    if (search) {
      whereClause.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { email: { contains: search, mode: 'insensitive' } }
      ];
    }

    const users = await prisma.user.findMany({
      where: whereClause,
      include: {
        entity: {
          select: {
            id: true,
            name: true
          }
        },
        _count: {
          select: {
            clientReservations: true,
            supervisorProjects: true,
            clientProjects: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      },
      skip: parseInt(skip),
      take: parseInt(limit)
    });

    const total = await prisma.user.count({ where: whereClause });

    res.json({
      users,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({
      error: 'Failed to retrieve users',
      message: 'An error occurred while fetching users'
    });
  }
});

// Get single user
router.get('/:id', authenticateToken, requireOwnershipOrAdmin('user'), async (req, res) => {
  try {
    const { id } = req.params;

    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        entity: {
          select: {
            id: true,
            name: true,
            notes: true
          }
        },
        clientReservations: {
          include: {
            field: {
              select: {
                id: true,
                name: true,
                location: true
              }
            }
          },
          orderBy: {
            createdAt: 'desc'
          }
        },
        supervisorProjects: {
          include: {
            client: {
              select: {
                id: true,
                name: true,
                email: true
              }
            },
            field: {
              select: {
                id: true,
                name: true,
                location: true
              }
            }
          },
          orderBy: {
            startDate: 'desc'
          }
        },
        clientProjects: {
          include: {
            supervisor: {
              select: {
                id: true,
                name: true,
                email: true
              }
            },
            field: {
              select: {
                id: true,
                name: true,
                location: true
              }
            }
          },
          orderBy: {
            startDate: 'desc'
          }
        }
      }
    });

    if (!user) {
      return res.status(404).json({
        error: 'User Not Found',
        message: 'The requested user was not found'
      });
    }

    // Remove sensitive information
    const { passwordHash, verificationToken, resetToken, resetTokenExpiry, ...safeUser } = user;

    res.json({ user: safeUser });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({
      error: 'Failed to retrieve user',
      message: 'An error occurred while fetching the user'
    });
  }
});

// Create new user (Admin only)
router.post('/', authenticateToken, requireRole('ADMIN'), createUserValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { email, password, name, role, entityId } = req.body;

    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email }
    });

    if (existingUser) {
      return res.status(409).json({
        error: 'User Already Exists',
        message: 'A user with this email already exists'
      });
    }

    // Hash password
    const saltRounds = 12;
    const passwordHash = await bcrypt.hash(password, saltRounds);

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        name,
        role,
        entityId,
        isVerified: true // Admin-created users are automatically verified
      },
      include: {
        entity: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });

    // Remove sensitive information
    const { passwordHash: _, ...safeUser } = user;

    res.status(201).json({
      message: 'User created successfully',
      user: safeUser
    });
  } catch (error) {
    console.error('Create user error:', error);
    res.status(500).json({
      error: 'Failed to create user',
      message: 'An error occurred while creating the user'
    });
  }
});

// Update user
router.put('/:id', authenticateToken, requireOwnershipOrAdmin('user'), updateUserValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { id } = req.params;
    const { email, name, role, entityId } = req.body;

    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id }
    });

    if (!existingUser) {
      return res.status(404).json({
        error: 'User Not Found',
        message: 'The requested user was not found'
      });
    }

    // Check if email is being changed and if it conflicts with existing user
    if (email && email !== existingUser.email) {
      const emailConflict = await prisma.user.findFirst({
        where: {
          email,
          id: {
            not: id
          }
        }
      });

      if (emailConflict) {
        return res.status(409).json({
          error: 'Email Already Exists',
          message: 'A user with this email already exists'
        });
      }
    }

    // Only admin can change roles
    if (role && req.user.role !== 'ADMIN') {
      return res.status(403).json({
        error: 'Insufficient Permissions',
        message: 'Only administrators can change user roles'
      });
    }

    // Update user
    const updatedUser = await prisma.user.update({
      where: { id },
      data: {
        email,
        name,
        role,
        entityId
      },
      include: {
        entity: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });

    // Remove sensitive information
    const { passwordHash, verificationToken, resetToken, resetTokenExpiry, ...safeUser } = updatedUser;

    res.json({
      message: 'User updated successfully',
      user: safeUser
    });
  } catch (error) {
    console.error('Update user error:', error);
    res.status(500).json({
      error: 'Failed to update user',
      message: 'An error occurred while updating the user'
    });
  }
});

// Change password
router.patch('/:id/password', authenticateToken, requireOwnershipOrAdmin('user'), changePasswordValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { id } = req.params;
    const { currentPassword, newPassword } = req.body;

    // Get user with password hash
    const user = await prisma.user.findUnique({
      where: { id }
    });

    if (!user) {
      return res.status(404).json({
        error: 'User Not Found',
        message: 'The requested user was not found'
      });
    }

    // Verify current password
    const isValidPassword = await bcrypt.compare(currentPassword, user.passwordHash);
    if (!isValidPassword) {
      return res.status(400).json({
        error: 'Invalid Current Password',
        message: 'Current password is incorrect'
      });
    }

    // Hash new password
    const saltRounds = 12;
    const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);

    // Update password
    await prisma.user.update({
      where: { id },
      data: {
        passwordHash: newPasswordHash
      }
    });

    res.json({
      message: 'Password changed successfully'
    });
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({
      error: 'Failed to change password',
      message: 'An error occurred while changing the password'
    });
  }
});

// Delete user (Admin only)
router.delete('/:id', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  try {
    const { id } = req.params;

    // Check if user exists
    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        clientReservations: true,
        supervisorProjects: true,
        clientProjects: true
      }
    });

    if (!user) {
      return res.status(404).json({
        error: 'User Not Found',
        message: 'The requested user was not found'
      });
    }

    // Check if user has active projects or reservations
    const hasActiveProjects = user.supervisorProjects.some(p => 
      ['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(p.status)
    ) || user.clientProjects.some(p => 
      ['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(p.status)
    );

    const hasPendingReservations = user.clientReservations.some(r => r.status === 'PENDING');

    if (hasActiveProjects) {
      return res.status(400).json({
        error: 'Cannot Delete User',
        message: 'Cannot delete user with active projects'
      });
    }

    if (hasPendingReservations) {
      return res.status(400).json({
        error: 'Cannot Delete User',
        message: 'Cannot delete user with pending reservations'
      });
    }

    // Delete user
    await prisma.user.delete({
      where: { id }
    });

    res.json({
      message: 'User deleted successfully'
    });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({
      error: 'Failed to delete user',
      message: 'An error occurred while deleting the user'
    });
  }
});

// Get supervisors (for dropdown selection)
router.get('/supervisors/list', authenticateToken, async (req, res) => {
  try {
    const supervisors = await prisma.user.findMany({
      where: {
        role: 'SUPERVISOR',
        isVerified: true
      },
      select: {
        id: true,
        name: true,
        email: true
      },
      orderBy: {
        name: 'asc'
      }
    });

    res.json({ supervisors });
  } catch (error) {
    console.error('Get supervisors error:', error);
    res.status(500).json({
      error: 'Failed to retrieve supervisors',
      message: 'An error occurred while fetching supervisors'
    });
  }
});

// Get clients (for dropdown selection)
router.get('/clients/list', authenticateToken, async (req, res) => {
  try {
    const clients = await prisma.user.findMany({
      where: {
        role: 'CLIENT',
        isVerified: true
      },
      select: {
        id: true,
        name: true,
        email: true,
        entity: {
          select: {
            id: true,
            name: true
          }
        }
      },
      orderBy: {
        name: 'asc'
      }
    });

    res.json({ clients });
  } catch (error) {
    console.error('Get clients error:', error);
    res.status(500).json({
      error: 'Failed to retrieve clients',
      message: 'An error occurred while fetching clients'
    });
  }
});

// Get user statistics
router.get('/:id/statistics', authenticateToken, requireOwnershipOrAdmin('user'), async (req, res) => {
  try {
    const { id } = req.params;

    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        clientReservations: {
          include: {
            field: {
              select: {
                name: true
              }
            }
          }
        },
        supervisorProjects: {
          include: {
            field: {
              select: {
                name: true
              }
            }
          }
        },
        clientProjects: {
          include: {
            field: {
              select: {
                name: true
              }
            }
          }
        }
      }
    });

    if (!user) {
      return res.status(404).json({
        error: 'User Not Found',
        message: 'The requested user was not found'
      });
    }

    // Calculate statistics based on user role
    let statistics = {};

    if (user.role === 'CLIENT') {
      const reservationStats = await prisma.reservation.groupBy({
        by: ['status'],
        _count: { status: true },
        where: { clientId: id }
      });

      const projectStats = await prisma.project.groupBy({
        by: ['status'],
        _count: { status: true },
        where: { clientId: id }
      });

      statistics = {
        reservationStatusDistribution: reservationStats,
        projectStatusDistribution: projectStats,
        totalReservations: user.clientReservations.length,
        totalProjects: user.clientProjects.length
      };
    } else if (user.role === 'SUPERVISOR') {
      const projectStats = await prisma.project.groupBy({
        by: ['status'],
        _count: { status: true },
        where: { supervisorId: id }
      });

      const totalSurfaceSupervised = user.supervisorProjects
        .filter(p => ['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(p.status))
        .reduce((sum, p) => sum + p.surfaceM2, 0);

      statistics = {
        projectStatusDistribution: projectStats,
        totalProjects: user.supervisorProjects.length,
        totalSurfaceSupervised,
        activeProjects: user.supervisorProjects.filter(p => 
          ['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(p.status)
        ).length
      };
    }

    res.json({ statistics });
  } catch (error) {
    console.error('Get user statistics error:', error);
    res.status(500).json({
      error: 'Failed to retrieve user statistics',
      message: 'An error occurred while fetching user statistics'
    });
  }
});

module.exports = router;

# ==== src/routes/fields.js ====

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { authenticateToken, requireRole } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

// Validation schemas
const createFieldValidation = [
  body('name').trim().isLength({ min: 2 }).withMessage('Field name must be at least 2 characters'),
  body('location').trim().isLength({ min: 2 }).withMessage('Location must be at least 2 characters'),
  body('totalSurfaceM2').isFloat({ min: 0.1 }).withMessage('Total surface area must be greater than 0'),
  body('status').optional().isIn(['ACTIVE', 'INACTIVE']).withMessage('Status must be ACTIVE or INACTIVE')
];

const updateFieldValidation = [
  body('name').optional().trim().isLength({ min: 2 }).withMessage('Field name must be at least 2 characters'),
  body('location').optional().trim().isLength({ min: 2 }).withMessage('Location must be at least 2 characters'),
  body('totalSurfaceM2').optional().isFloat({ min: 0.1 }).withMessage('Total surface area must be greater than 0'),
  body('status').optional().isIn(['ACTIVE', 'INACTIVE']).withMessage('Status must be ACTIVE or INACTIVE')
];

// Get all fields
router.get('/', authenticateToken, async (req, res) => {
  try {
    const { page = 1, limit = 10, status, search } = req.query;
    const skip = (page - 1) * limit;

    let whereClause = {};

    // Filter by status if provided
    if (status) {
      whereClause.status = status;
    }

    // Search functionality
    if (search) {
      whereClause.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { location: { contains: search, mode: 'insensitive' } }
      ];
    }

    const fields = await prisma.field.findMany({
      where: whereClause,
      include: {
        projects: {
          include: {
            client: {
              select: {
                id: true,
                name: true,
                email: true,
                entity: {
                  select: {
                    id: true,
                    name: true,
                    notes: true
                  }
                }
              }
            },
            supervisor: {
              select: {
                id: true,
                name: true,
                email: true
              }
            },
            activityType: {
              select: {
                id: true,
                label: true
              }
            }
          }
        },
        reservations: {
          include: {
            client: {
              select: {
                id: true,
                name: true,
                email: true,
                entity: {
                  select: {
                    id: true,
                    name: true,
                    notes: true
                  }
                }
              }
            },
            supervisor: {
              select: {
                id: true,
                name: true,
                email: true
              }
            },
            field: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        _count: {
          select: {
            projects: true,
            reservations: true
          }
        }
      },
      orderBy: {
        name: 'asc'
      },
      skip: parseInt(skip),
      take: parseInt(limit)
    });

    const total = await prisma.field.count({ where: whereClause });

    // Calculate utilization percentage for each field
    const fieldsWithUtilization = fields.map(field => {
      const usedSurface = field.projects.reduce((sum, project) => sum + project.surfaceM2, 0);
      const utilizationPercentage = (usedSurface / field.totalSurfaceM2) * 100;
      
      return {
        ...field,
        utilizationPercentage: Math.round(utilizationPercentage * 100) / 100,
        usedSurfaceM2: usedSurface
      };
    });

    res.json({
      fields: fieldsWithUtilization,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get fields error:', error);
    res.status(500).json({
      error: 'Failed to retrieve fields',
      message: 'An error occurred while fetching fields'
    });
  }
});

// Get single field
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const field = await prisma.field.findUnique({
      where: { id },
      include: {
        projects: {
          include: {
            client: {
              select: {
                id: true,
                name: true,
                email: true
              }
            },
            supervisor: {
              select: {
                id: true,
                name: true,
                email: true
              }
            },
            activityType: {
              select: {
                id: true,
                label: true
              }
            }
          },
          orderBy: {
            startDate: 'desc'
          }
        },
        reservations: {
          include: {
            client: {
              select: {
                id: true,
                name: true,
                email: true
              }
            },
            supervisor: {
              select: {
                id: true,
                name: true,
                email: true
              }
            },
            field: {
              select: {
                id: true,
                name: true
              }
            }
          },
          orderBy: {
            createdAt: 'desc'
          }
        }
      }
    });

    if (!field) {
      return res.status(404).json({
        error: 'Field Not Found',
        message: 'The requested field was not found'
      });
    }

    // Calculate utilization
    const usedSurface = field.projects
      .filter(project => ['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(project.status))
      .reduce((sum, project) => sum + project.surfaceM2, 0);
    
    const utilizationPercentage = (usedSurface / field.totalSurfaceM2) * 100;

    res.json({
      field: {
        ...field,
        utilizationPercentage: Math.round(utilizationPercentage * 100) / 100,
        usedSurfaceM2: usedSurface
      }
    });
  } catch (error) {
    console.error('Get field error:', error);
    res.status(500).json({
      error: 'Failed to retrieve field',
      message: 'An error occurred while fetching the field'
    });
  }
});

// Create new field
router.post('/', authenticateToken, requireRole('ADMIN'), createFieldValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { name, location, totalSurfaceM2, status = 'ACTIVE', notes } = req.body;

    // Check if field with same name already exists
    const existingField = await prisma.field.findFirst({
      where: {
        name: {
          equals: name,
          mode: 'insensitive'
        }
      }
    });

    if (existingField) {
      return res.status(409).json({
        error: 'Field Already Exists',
        message: 'A field with this name already exists'
      });
    }

    const field = await prisma.field.create({
      data: {
        name,
        location,
        totalSurfaceM2,
        freeSurfaceM2: totalSurfaceM2, // Initially, all surface is free
        status,
        notes
      }
    });

    res.status(201).json({
      message: 'Field created successfully',
      field
    });
  } catch (error) {
    console.error('Create field error:', error);
    res.status(500).json({
      error: 'Failed to create field',
      message: 'An error occurred while creating the field'
    });
  }
});

// Update field
router.put('/:id', authenticateToken, requireRole('ADMIN'), updateFieldValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { id } = req.params;
    const { name, location, totalSurfaceM2, status, notes } = req.body;

    // Check if field exists
    const existingField = await prisma.field.findUnique({
      where: { id },
      include: {
        projects: {
          where: {
            status: {
              in: ['EN_COURS', 'PROGRAMME', 'A_LANCER']
            }
          }
        }
      }
    });

    if (!existingField) {
      return res.status(404).json({
        error: 'Field Not Found',
        message: 'The requested field was not found'
      });
    }

    // Check if field has active projects and is being deactivated
    if (status === 'INACTIVE' && existingField.projects.length > 0) {
      return res.status(400).json({
        error: 'Cannot Deactivate Field',
        message: 'Cannot deactivate field with active projects'
      });
    }

    // Check if new total surface is sufficient for existing projects
    if (totalSurfaceM2) {
      const usedSurface = existingField.projects.reduce((sum, project) => sum + project.surfaceM2, 0);
      if (totalSurfaceM2 < usedSurface) {
        return res.status(400).json({
          error: 'Insufficient Surface Area',
          message: `New total surface area (${totalSurfaceM2} m¬≤) is less than currently used area (${usedSurface} m¬≤)`
        });
      }
    }

    // Check if name is being changed and if it conflicts with existing field
    if (name && name !== existingField.name) {
      const nameConflict = await prisma.field.findFirst({
        where: {
          name: {
            equals: name,
            mode: 'insensitive'
          },
          id: {
            not: id
          }
        }
      });

      if (nameConflict) {
        return res.status(409).json({
          error: 'Field Name Conflict',
          message: 'A field with this name already exists'
        });
      }
    }

    // Calculate new free surface if total surface is being updated
    let freeSurfaceM2 = existingField.freeSurfaceM2;
    if (totalSurfaceM2 && totalSurfaceM2 !== existingField.totalSurfaceM2) {
      const usedSurface = existingField.projects.reduce((sum, project) => sum + project.surfaceM2, 0);
      freeSurfaceM2 = totalSurfaceM2 - usedSurface;
    }

    const updatedField = await prisma.field.update({
      where: { id },
      data: {
        name,
        location,
        totalSurfaceM2,
        freeSurfaceM2,
        status,
        notes
      }
    });

    res.json({
      message: 'Field updated successfully',
      field: updatedField
    });
  } catch (error) {
    console.error('Update field error:', error);
    res.status(500).json({
      error: 'Failed to update field',
      message: 'An error occurred while updating the field'
    });
  }
});

// Delete field
router.delete('/:id', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  try {
    const { id } = req.params;

    // Check if field exists and has active projects
    const field = await prisma.field.findUnique({
      where: { id },
      include: {
        projects: {
          where: {
            status: {
              in: ['EN_COURS', 'PROGRAMME', 'A_LANCER']
            }
          }
        },
        reservations: {
          where: {
            status: 'PENDING'
          }
        }
      }
    });

    if (!field) {
      return res.status(404).json({
        error: 'Field Not Found',
        message: 'The requested field was not found'
      });
    }

    if (field.projects.length > 0) {
      return res.status(400).json({
        error: 'Cannot Delete Field',
        message: 'Cannot delete field with active projects'
      });
    }

    if (field.reservations.length > 0) {
      return res.status(400).json({
        error: 'Cannot Delete Field',
        message: 'Cannot delete field with pending reservations'
      });
    }

    await prisma.field.delete({
      where: { id }
    });

    res.json({
      message: 'Field deleted successfully'
    });
  } catch (error) {
    console.error('Delete field error:', error);
    res.status(500).json({
      error: 'Failed to delete field',
      message: 'An error occurred while deleting the field'
    });
  }
});

// Get field statistics
router.get('/:id/statistics', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const field = await prisma.field.findUnique({
      where: { id },
      include: {
        projects: {
          include: {
            activityType: true
          }
        }
      }
    });

    if (!field) {
      return res.status(404).json({
        error: 'Field Not Found',
        message: 'The requested field was not found'
      });
    }

    // Calculate statistics
    const totalProjects = field.projects.length;
    const activeProjects = field.projects.filter(p => ['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(p.status)).length;
    const completedProjects = field.projects.filter(p => p.status === 'FINALISE').length;
    
    const usedSurface = field.projects
      .filter(p => ['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(p.status))
      .reduce((sum, p) => sum + p.surfaceM2, 0);
    
    const utilizationPercentage = (usedSurface / field.totalSurfaceM2) * 100;

    // Activity type distribution
    const activityTypeStats = {};
    field.projects.forEach(project => {
      if (project.activityType) {
        const label = project.activityType.label;
        activityTypeStats[label] = (activityTypeStats[label] || 0) + 1;
      }
    });

    // Monthly project timeline
    const monthlyStats = {};
    field.projects.forEach(project => {
      const startMonth = new Date(project.startDate).toISOString().slice(0, 7); // YYYY-MM
      monthlyStats[startMonth] = (monthlyStats[startMonth] || 0) + 1;
    });

    res.json({
      statistics: {
        totalProjects,
        activeProjects,
        completedProjects,
        usedSurfaceM2: usedSurface,
        freeSurfaceM2: field.freeSurfaceM2,
        utilizationPercentage: Math.round(utilizationPercentage * 100) / 100,
        activityTypeDistribution: activityTypeStats,
        monthlyTimeline: monthlyStats
      }
    });
  } catch (error) {
    console.error('Get field statistics error:', error);
    res.status(500).json({
      error: 'Failed to retrieve field statistics',
      message: 'An error occurred while fetching field statistics'
    });
  }
});

module.exports = router; 

# ==== src/routes/priceOffers.js ====

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { authenticateToken, requireRole } = require('../middleware/auth');
const PDFDocument = require('pdfkit');

const router = express.Router();
const prisma = new PrismaClient();

// Validation schemas
const createPriceOfferValidation = [
  body('destinataire').trim().isLength({ min: 2 }).withMessage('Destinataire must be at least 2 characters'),
  body('demandeur').trim().isLength({ min: 2 }).withMessage('Demandeur must be at least 2 characters'),
  body('address').trim().isLength({ min: 5 }).withMessage('Address must be at least 5 characters'),
  body('itemDesignation').trim().isLength({ min: 3 }).withMessage('Item designation must be at least 3 characters'),
  body('unit').trim().isLength({ min: 1 }).withMessage('Unit is required'),
  body('quantity').isFloat({ min: 0.1 }).withMessage('Quantity must be greater than 0'),
  body('contact').optional().trim(),
  body('orderNumber').optional().trim(),
  body('techDescription').optional().trim()
];

const updatePriceOfferValidation = [
  body('destinataire').optional().trim().isLength({ min: 2 }).withMessage('Destinataire must be at least 2 characters'),
  body('demandeur').optional().trim().isLength({ min: 2 }).withMessage('Demandeur must be at least 2 characters'),
  body('address').optional().trim().isLength({ min: 5 }).withMessage('Address must be at least 5 characters'),
  body('itemDesignation').optional().trim().isLength({ min: 3 }).withMessage('Item designation must be at least 3 characters'),
  body('unit').optional().trim().isLength({ min: 1 }).withMessage('Unit cannot be empty'),
  body('quantity').optional().isFloat({ min: 0.1 }).withMessage('Quantity must be greater than 0'),
  body('contact').optional().trim(),
  body('orderNumber').optional().trim(),
  body('techDescription').optional().trim(),
  body('status').optional().isIn(['PENDING', 'SENT', 'ACCEPTED', 'REJECTED']).withMessage('Invalid status')
];

// Get all price offers
router.get('/', authenticateToken, async (req, res) => {
  try {
    const { page = 1, limit = 10, status, search, startDate, endDate } = req.query;
    const skip = (page - 1) * limit;

    let whereClause = {};

    // Filter by status if provided
    if (status) {
      whereClause.status = status;
    }

    // Filter by date range if provided
    if (startDate && endDate) {
      whereClause.dateSent = {
        gte: new Date(startDate),
        lte: new Date(endDate)
      };
    }

    // Search functionality
    if (search) {
      whereClause.OR = [
        { destinataire: { contains: search, mode: 'insensitive' } },
        { demandeur: { contains: search, mode: 'insensitive' } },
        { itemDesignation: { contains: search, mode: 'insensitive' } },
        { orderNumber: { contains: search, mode: 'insensitive' } }
      ];
    }

    // Role-based filtering
    if (req.user.role === 'CLIENT') {
      whereClause.createdById = req.user.id;
    }
    // ADMIN and SUPERVISOR can see all offers

    const priceOffers = await prisma.priceOffer.findMany({
      where: whereClause,
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
      orderBy: {
        dateSent: 'desc'
      },
      skip: parseInt(skip),
      take: parseInt(limit)
    });

    const total = await prisma.priceOffer.count({ where: whereClause });

    res.json({
      priceOffers,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get price offers error:', error);
    res.status(500).json({
      error: 'Failed to retrieve price offers',
      message: 'An error occurred while fetching price offers'
    });
  }
});

// Get single price offer
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const priceOffer = await prisma.priceOffer.findUnique({
      where: { id },
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    if (!priceOffer) {
      return res.status(404).json({
        error: 'Price Offer Not Found',
        message: 'The requested price offer was not found'
      });
    }

    // Check access permissions
    if (req.user.role === 'CLIENT' && priceOffer.createdById !== req.user.id) {
      return res.status(403).json({
        error: 'Access Denied',
        message: 'You can only access your own price offers'
      });
    }

    res.json({ priceOffer });
  } catch (error) {
    console.error('Get price offer error:', error);
    res.status(500).json({
      error: 'Failed to retrieve price offer',
      message: 'An error occurred while fetching the price offer'
    });
  }
});

// Create new price offer
router.post('/', authenticateToken, requireRole(['ADMIN', 'SUPERVISOR']), createPriceOfferValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const {
      destinataire,
      demandeur,
      contact,
      address,
      orderNumber,
      itemDesignation,
      unit,
      techDescription,
      quantity
    } = req.body;

    const priceOffer = await prisma.priceOffer.create({
      data: {
        destinataire,
        demandeur,
        contact,
        address,
        orderNumber,
        itemDesignation,
        unit,
        techDescription,
        quantity,
        dateSent: new Date(),
        status: 'PENDING',
        createdById: req.user.id
      },
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    res.status(201).json({
      message: 'Price offer created successfully',
      priceOffer
    });
  } catch (error) {
    console.error('Create price offer error:', error);
    res.status(500).json({
      error: 'Failed to create price offer',
      message: 'An error occurred while creating the price offer'
    });
  }
});

// Update price offer
router.put('/:id', authenticateToken, requireRole(['ADMIN', 'SUPERVISOR']), updatePriceOfferValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { id } = req.params;
    const updateData = req.body;

    // Check if price offer exists
    const existingOffer = await prisma.priceOffer.findUnique({
      where: { id }
    });

    if (!existingOffer) {
      return res.status(404).json({
        error: 'Price Offer Not Found',
        message: 'The requested price offer was not found'
      });
    }

    const priceOffer = await prisma.priceOffer.update({
      where: { id },
      data: updateData,
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    res.json({
      message: 'Price offer updated successfully',
      priceOffer
    });
  } catch (error) {
    console.error('Update price offer error:', error);
    res.status(500).json({
      error: 'Failed to update price offer',
      message: 'An error occurred while updating the price offer'
    });
  }
});

// Update price offer status
router.patch('/:id/status', authenticateToken, requireRole(['ADMIN', 'SUPERVISOR']), async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    if (!['PENDING', 'SENT', 'ACCEPTED', 'REJECTED'].includes(status)) {
      return res.status(400).json({
        error: 'Invalid Status',
        message: 'Status must be PENDING, SENT, ACCEPTED, or REJECTED'
      });
    }

    const priceOffer = await prisma.priceOffer.update({
      where: { id },
      data: {
        status,
        dateSent: status === 'SENT' ? new Date() : undefined
      },
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    res.json({
      message: 'Price offer status updated successfully',
      priceOffer
    });
  } catch (error) {
    console.error('Update price offer status error:', error);
    res.status(500).json({
      error: 'Failed to update price offer status',
      message: 'An error occurred while updating the price offer status'
    });
  }
});

// Delete price offer
router.delete('/:id', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  try {
    const { id } = req.params;

    const priceOffer = await prisma.priceOffer.findUnique({
      where: { id }
    });

    if (!priceOffer) {
      return res.status(404).json({
        error: 'Price Offer Not Found',
        message: 'The requested price offer was not found'
      });
    }

    await prisma.priceOffer.delete({
      where: { id }
    });

    res.json({
      message: 'Price offer deleted successfully'
    });
  } catch (error) {
    console.error('Delete price offer error:', error);
    res.status(500).json({
      error: 'Failed to delete price offer',
      message: 'An error occurred while deleting the price offer'
    });
  }
});

// Generate PDF for price offer
router.get('/:id/pdf', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const priceOffer = await prisma.priceOffer.findUnique({
      where: { id },
      include: {
        createdBy: {
          select: {
            name: true
          }
        }
      }
    });

    if (!priceOffer) {
      return res.status(404).json({
        error: 'Price Offer Not Found',
        message: 'The requested price offer was not found'
      });
    }

    // Check access permissions
    if (req.user.role === 'CLIENT' && priceOffer.createdById !== req.user.id) {
      return res.status(403).json({
        error: 'Access Denied',
        message: 'You can only access your own price offers'
      });
    }

    // Create PDF
    const doc = new PDFDocument();
    
    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="price-offer-${id}.pdf"`);

    // Pipe PDF to response
    doc.pipe(res);

    // Add content to PDF
    doc.fontSize(18).text('AITTC / UM6P', { align: 'center' });
    doc.moveDown();
    doc.fontSize(14).text('Ferme exp√©rimentale site Ben Gu√©rir', { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text('Fiche : offre de prix', { align: 'center' });
    doc.moveDown();

    // Form details
    doc.fontSize(10);
    doc.text(`Code : F.47`);
    doc.text(`Version : 01`);
    doc.text(`Date : ${new Date(priceOffer.dateSent).toLocaleDateString()}`);
    doc.moveDown();

    doc.text(`Demande N¬∞ : ${priceOffer.orderNumber || 'N/A'}`);
    doc.text(`Date : ${new Date(priceOffer.dateSent).toLocaleDateString()}`);
    doc.moveDown();

    doc.text(`Destinataire : ${priceOffer.destinataire}`);
    doc.text(`Demandeur : ${priceOffer.demandeur}`);
    if (priceOffer.contact) {
      doc.text(`Contacts : ${priceOffer.contact}`);
    }
    doc.text(`Adresse : ${priceOffer.address}`);
    doc.moveDown();

    // Item details
    doc.text('Num√©ro d\'ordre : 1');
    doc.text(`D√©signation article : ${priceOffer.itemDesignation}`);
    if (priceOffer.techDescription) {
      doc.text(`Description technique : ${priceOffer.techDescription}`);
    }
    doc.text(`Unit√© : ${priceOffer.unit}`);
    doc.text(`Quantit√© : ${priceOffer.quantity}`);
    doc.moveDown();

    // Footer
    doc.text('Centre AITTC de l\'Universit√© Mohamed 6 Polytechniques (UM6P)');
    doc.text('Adresse : Lot 660,Hay Moulay Rachid 43150, Ben Gu√©rir - www.um6p.ma');
    doc.text('R.C.n¬∞ 1037-Patente n¬∞ 45408944-I.F. 14437938-CNSS n¬∞ 9515919-ICE n¬∞ 000189568000063');
    doc.text('Morocco');

    // Finalize PDF
    doc.end();
  } catch (error) {
    console.error('Generate PDF error:', error);
    res.status(500).json({
      error: 'Failed to generate PDF',
      message: 'An error occurred while generating the PDF'
    });
  }
});

// Get price offer statistics
router.get('/statistics/overview', authenticateToken, async (req, res) => {
  try {
    let whereClause = {};

    // Role-based filtering
    if (req.user.role === 'CLIENT') {
      whereClause.createdById = req.user.id;
    }

    // Get total counts
    const totalOffers = await prisma.priceOffer.count({ where: whereClause });
    const pendingOffers = await prisma.priceOffer.count({
      where: { ...whereClause, status: 'PENDING' }
    });
    const sentOffers = await prisma.priceOffer.count({
      where: { ...whereClause, status: 'SENT' }
    });
    const acceptedOffers = await prisma.priceOffer.count({
      where: { ...whereClause, status: 'ACCEPTED' }
    });
    const rejectedOffers = await prisma.priceOffer.count({
      where: { ...whereClause, status: 'REJECTED' }
    });

    // Get status distribution
    const statusStats = await prisma.priceOffer.groupBy({
      by: ['status'],
      _count: {
        status: true
      },
      where: whereClause
    });

    // Get monthly trends
    const monthlyStats = await prisma.priceOffer.groupBy({
      by: ['dateSent'],
      _count: {
        id: true
      },
      where: {
        ...whereClause,
        dateSent: {
          gte: new Date(new Date().getFullYear(), 0, 1) // From January 1st of current year
        }
      }
    });

    res.json({
      overview: {
        totalOffers,
        pendingOffers,
        sentOffers,
        acceptedOffers,
        rejectedOffers
      },
      distributions: {
        status: statusStats,
        monthly: monthlyStats
      }
    });
  } catch (error) {
    console.error('Get price offer statistics error:', error);
    res.status(500).json({
      error: 'Failed to retrieve price offer statistics',
      message: 'An error occurred while fetching price offer statistics'
    });
  }
});

module.exports = router; 

# ==== src/routes/projects.js ====

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { authenticateToken, requireRole, requireOwnershipOrAdmin, requireSupervisorAccess } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

// Validation schemas
const createProjectValidation = [
  body('title').trim().isLength({ min: 3 }).withMessage('Project title must be at least 3 characters'),
  body('fieldId').notEmpty().withMessage('Field ID is required'),
  body('clientId').notEmpty().withMessage('Client ID is required'),
  body('supervisorId').notEmpty().withMessage('Supervisor ID is required'),
  body('surfaceM2').isFloat({ min: 0.1 }).withMessage('Surface area must be greater than 0'),
  body('startDate').isISO8601().withMessage('Start date must be a valid date'),
  body('endDate').optional().isISO8601().withMessage('End date must be a valid date'),
  body('activityTypeId').optional().isUUID().withMessage('Activity type ID must be a valid UUID')
];

const updateProjectValidation = [
  body('title').optional().trim().isLength({ min: 3 }).withMessage('Project title must be at least 3 characters'),
  body('surfaceM2').optional().isFloat({ min: 0.1 }).withMessage('Surface area must be greater than 0'),
  body('startDate').optional().isISO8601().withMessage('Start date must be a valid date'),
  body('endDate').optional().isISO8601().withMessage('End date must be a valid date'),
  body('status').optional().isIn(['EN_COURS', 'FINALISE', 'PROGRAMME', 'A_LANCER']).withMessage('Invalid project status'),
  body('activityTypeId').optional().isUUID().withMessage('Activity type ID must be a valid UUID')
];

// Get all projects (filtered by user role)
router.get('/', authenticateToken, async (req, res) => {
  try {
    const { page = 1, limit = 10, status, fieldId, activityTypeId, search } = req.query;
    const skip = (page - 1) * limit;

    let whereClause = {};

    // Filter by status if provided
    if (status) {
      whereClause.status = status;
    }

    // Filter by field if provided
    if (fieldId) {
      whereClause.fieldId = fieldId;
    }

    // Filter by activity type if provided
    if (activityTypeId) {
      whereClause.activityTypeId = activityTypeId;
    }

    // Search functionality
    if (search) {
      whereClause.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { client: { name: { contains: search, mode: 'insensitive' } } },
        { supervisor: { name: { contains: search, mode: 'insensitive' } } }
      ];
    }

    // Role-based filtering
    if (req.user.role === 'CLIENT') {
      whereClause.clientId = req.user.id;
    } else if (req.user.role === 'SUPERVISOR') {
      whereClause.supervisorId = req.user.id;
    }
    // ADMIN can see all projects

    const projects = await prisma.project.findMany({
      where: whereClause,
      include: {
        client: {
          select: {
            id: true,
            name: true,
            email: true,
            entity: {
              select: {
                id: true,
                name: true,
                notes: true
              }
            }
          }
        },
        supervisor: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        field: {
          select: {
            id: true,
            name: true,
            location: true,
            totalSurfaceM2: true,
            freeSurfaceM2: true
          }
        },
        activityType: {
          select: {
            id: true,
            label: true,
            description: true
          }
        }
      },
      orderBy: {
        startDate: 'desc'
      },
      skip: parseInt(skip),
      take: parseInt(limit)
    });

    const total = await prisma.project.count({ where: whereClause });

    res.json({
      projects,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get projects error:', error);
    res.status(500).json({
      error: 'Failed to retrieve projects',
      message: 'An error occurred while fetching projects'
    });
  }
});

// Get single project
router.get('/:id', authenticateToken, requireOwnershipOrAdmin('project'), async (req, res) => {
  try {
    const { id } = req.params;

    const project = await prisma.project.findUnique({
      where: { id },
      include: {
        client: {
          select: {
            id: true,
            name: true,
            email: true,
            entity: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        supervisor: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        field: {
          select: {
            id: true,
            name: true,
            location: true,
            totalSurfaceM2: true,
            freeSurfaceM2: true,
            status: true
          }
        },
        activityType: {
          select: {
            id: true,
            label: true,
            description: true
          }
        },
        reservation: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });

    if (!project) {
      return res.status(404).json({
        error: 'Project Not Found',
        message: 'The requested project was not found'
      });
    }

    res.json({ project });
  } catch (error) {
    console.error('Get project error:', error);
    res.status(500).json({
      error: 'Failed to retrieve project',
      message: 'An error occurred while fetching the project'
    });
  }
});

// Create new project (Admin only)
router.post('/', authenticateToken, requireRole('ADMIN'), createProjectValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { title, fieldId, clientId, supervisorId, surfaceM2, startDate, endDate, activityTypeId, status = 'A_LANCER' } = req.body;

    // Check if field exists and has sufficient free surface
    const field = await prisma.field.findUnique({
      where: { id: fieldId }
    });

    if (!field) {
      return res.status(404).json({
        error: 'Field Not Found',
        message: 'The specified field was not found'
      });
    }

    if (field.status !== 'ACTIVE') {
      return res.status(400).json({
        error: 'Field Not Available',
        message: 'The specified field is not available for projects'
      });
    }

    if (surfaceM2 > field.freeSurfaceM2) {
      return res.status(400).json({
        error: 'Insufficient Surface Area',
        message: `Requested surface area (${surfaceM2} m¬≤) exceeds available area (${field.freeSurfaceM2} m¬≤)`
      });
    }

    // Check if client exists
    const client = await prisma.user.findUnique({
      where: { id: clientId }
    });

    if (!client || client.role !== 'CLIENT') {
      return res.status(400).json({
        error: 'Invalid Client',
        message: 'The specified client is not valid'
      });
    }

    // Check if supervisor exists
    const supervisor = await prisma.user.findUnique({
      where: { id: supervisorId }
    });

    if (!supervisor || supervisor.role !== 'SUPERVISOR') {
      return res.status(400).json({
        error: 'Invalid Supervisor',
        message: 'The specified supervisor is not valid'
      });
    }

    // Use transaction to ensure data consistency
    const result = await prisma.$transaction(async (tx) => {
      // Create project
      const project = await tx.project.create({
        data: {
          title,
          fieldId,
          clientId,
          supervisorId,
          activityTypeId,
          surfaceM2,
          startDate: new Date(startDate),
          endDate: endDate ? new Date(endDate) : null,
          status
        },
        include: {
          client: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          supervisor: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          field: {
            select: {
              id: true,
              name: true,
              location: true
            }
          }
        }
      });

      // Update field free surface if project is active
      if (['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(status)) {
        await tx.field.update({
          where: { id: fieldId },
          data: {
            freeSurfaceM2: {
              decrement: surfaceM2
            }
          }
        });
      }

      return project;
    });

    res.status(201).json({
      message: 'Project created successfully',
      project: result
    });
  } catch (error) {
    console.error('Create project error:', error);
    res.status(500).json({
      error: 'Failed to create project',
      message: 'An error occurred while creating the project'
    });
  }
});

// Update project
router.put('/:id', authenticateToken, requireOwnershipOrAdmin('project'), updateProjectValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { id } = req.params;
    const { title, surfaceM2, startDate, endDate, status, activityTypeId, progressNotes } = req.body;

    // Get existing project
    const existingProject = await prisma.project.findUnique({
      where: { id },
      include: {
        field: true
      }
    });

    if (!existingProject) {
      return res.status(404).json({
        error: 'Project Not Found',
        message: 'The requested project was not found'
      });
    }

    // Use transaction to ensure data consistency
    const result = await prisma.$transaction(async (tx) => {
      let updatedData = {};

      // Handle surface area changes
      if (surfaceM2 && surfaceM2 !== existingProject.surfaceM2) {
        const surfaceDifference = surfaceM2 - existingProject.surfaceM2;
        
        // Check if field has sufficient free surface for increase
        if (surfaceDifference > 0 && surfaceDifference > existingProject.field.freeSurfaceM2) {
          throw new Error(`Insufficient surface area. Available: ${existingProject.field.freeSurfaceM2} m¬≤, Required: ${surfaceDifference} m¬≤`);
        }

        updatedData.surfaceM2 = surfaceM2;

        // Update field free surface
        await tx.field.update({
          where: { id: existingProject.fieldId },
          data: {
            freeSurfaceM2: {
              decrement: surfaceDifference
            }
          }
        });
      }

      // Handle status changes
      if (status && status !== existingProject.status) {
        updatedData.status = status;

        // If project is being finalized, release surface area back to field
        if (status === 'FINALISE' && existingProject.status !== 'FINALISE') {
          await tx.field.update({
            where: { id: existingProject.fieldId },
            data: {
              freeSurfaceM2: {
                increment: existingProject.surfaceM2
              }
            }
          });
        }
        // If project is being reactivated, reserve surface area again
        else if (existingProject.status === 'FINALISE' && status !== 'FINALISE') {
          await tx.field.update({
            where: { id: existingProject.fieldId },
            data: {
              freeSurfaceM2: {
                decrement: existingProject.surfaceM2
              }
            }
          });
        }
      }

      // Add other updates
      if (title) updatedData.title = title;
      if (startDate) updatedData.startDate = new Date(startDate);
      if (endDate) updatedData.endDate = new Date(endDate);
      if (activityTypeId) updatedData.activityTypeId = activityTypeId;
      if (progressNotes !== undefined) updatedData.progressNotes = progressNotes;

      // Update project
      const updatedProject = await tx.project.update({
        where: { id },
        data: updatedData,
        include: {
          client: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          supervisor: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          field: {
            select: {
              id: true,
              name: true,
              location: true
            }
          },
          activityType: {
            select: {
              id: true,
              label: true
            }
          }
        }
      });

      return updatedProject;
    });

    res.json({
      message: 'Project updated successfully',
      project: result
    });
  } catch (error) {
    console.error('Update project error:', error);
    res.status(500).json({
      error: 'Failed to update project',
      message: error.message || 'An error occurred while updating the project'
    });
  }
});

// Update project progress notes (Supervisor only)
router.patch('/:id/progress', authenticateToken, requireSupervisorAccess, async (req, res) => {
  try {
    const { id } = req.params;
    const { progressNotes } = req.body;

    if (!progressNotes || typeof progressNotes !== 'string') {
      return res.status(400).json({
        error: 'Invalid Progress Notes',
        message: 'Progress notes are required and must be a string'
      });
    }

    const project = await prisma.project.update({
      where: { id },
      data: {
        progressNotes
      },
      include: {
        client: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        supervisor: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        field: {
          select: {
            id: true,
            name: true,
            location: true
          }
        }
      }
    });

    res.json({
      message: 'Progress notes updated successfully',
      project
    });
  } catch (error) {
    console.error('Update project progress error:', error);
    res.status(500).json({
      error: 'Failed to update progress notes',
      message: 'An error occurred while updating progress notes'
    });
  }
});

// Delete project (Admin only)
router.delete('/:id', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  try {
    const { id } = req.params;

    const project = await prisma.project.findUnique({
      where: { id },
      include: {
        field: true
      }
    });

    if (!project) {
      return res.status(404).json({
        error: 'Project Not Found',
        message: 'The requested project was not found'
      });
    }

    // Use transaction to ensure data consistency
    await prisma.$transaction(async (tx) => {
      // Release surface area back to field if project is active
      if (['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(project.status)) {
        await tx.field.update({
          where: { id: project.fieldId },
          data: {
            freeSurfaceM2: {
              increment: project.surfaceM2
            }
          }
        });
      }

      // Delete project
      await tx.project.delete({
        where: { id }
      });
    });

    res.json({
      message: 'Project deleted successfully'
    });
  } catch (error) {
    console.error('Delete project error:', error);
    res.status(500).json({
      error: 'Failed to delete project',
      message: 'An error occurred while deleting the project'
    });
  }
});

// Get project statistics
router.get('/:id/statistics', authenticateToken, requireOwnershipOrAdmin('project'), async (req, res) => {
  try {
    const { id } = req.params;

    const project = await prisma.project.findUnique({
      where: { id },
      include: {
        field: {
          include: {
            projects: {
              where: {
                id: { not: id }
              }
            }
          }
        }
      }
    });

    if (!project) {
      return res.status(404).json({
        error: 'Project Not Found',
        message: 'The requested project was not found'
      });
    }

    // Calculate field utilization excluding this project
    const otherProjectsSurface = project.field.projects
      .filter(p => ['EN_COURS', 'PROGRAMME', 'A_LANCER'].includes(p.status))
      .reduce((sum, p) => sum + p.surfaceM2, 0);

    const fieldUtilizationPercentage = ((otherProjectsSurface + project.surfaceM2) / project.field.totalSurfaceM2) * 100;

    // Calculate project duration
    const startDate = new Date(project.startDate);
    const endDate = project.endDate ? new Date(project.endDate) : new Date();
    const durationDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));

    // Calculate progress percentage based on time
    const totalDuration = project.endDate ? 
      Math.ceil((new Date(project.endDate) - startDate) / (1000 * 60 * 60 * 24)) : 
      durationDays;
    
    const progressPercentage = totalDuration > 0 ? Math.min((durationDays / totalDuration) * 100, 100) : 0;

    res.json({
      statistics: {
        projectDuration: durationDays,
        progressPercentage: Math.round(progressPercentage * 100) / 100,
        fieldUtilizationPercentage: Math.round(fieldUtilizationPercentage * 100) / 100,
        surfaceUtilizationPercentage: (project.surfaceM2 / project.field.totalSurfaceM2) * 100
      }
    });
  } catch (error) {
    console.error('Get project statistics error:', error);
    res.status(500).json({
      error: 'Failed to retrieve project statistics',
      message: 'An error occurred while fetching project statistics'
    });
  }
});

module.exports = router; 

# ==== src/routes/entities.js ====

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { authenticateToken, requireRole } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

// Get all entities with users, projects, and fields
router.get('/', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  try {
    const entities = await prisma.entity.findMany({
      include: {
        users: {
          select: { id: true, name: true, email: true }
        }
      }
    });

    // For each entity, collect all projects for all users (as clients), with full links
    const result = [];
    for (const entity of entities) {
      // Get all projects for all users in this entity
      const userIds = entity.users.map(u => u.id);
      const projects = await prisma.project.findMany({
        where: { clientId: { in: userIds } },
        include: {
          field: { select: { id: true, name: true } },
          client: {
            select: {
              id: true,
              name: true,
              email: true,
              entity: { select: { id: true, name: true, notes: true } }
            }
          },
          supervisor: { select: { id: true, name: true, email: true } },
          activityType: { select: { id: true, label: true } }
        }
      });
      // Collect all fields used by this entity's projects
      const fields = projects.map(p => p.field).filter(Boolean);
      result.push({
        id: entity.id,
        name: entity.name,
        users: entity.users,
        projects,
        fields
      });
    }
    res.json({ entities: result });
  } catch (error) {
    console.error('Get entities error:', error);
    res.status(500).json({ error: 'Failed to retrieve entities' });
  }
});

module.exports = router; 

# ==== src/routes/inventory.js ====

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { authenticateToken, requireRole } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

// Validation schemas
const createInventoryItemValidation = [
  body('owner').trim().isLength({ min: 1 }).withMessage('Owner is required'),
  body('family').trim().isLength({ min: 1 }).withMessage('Family is required'),
  body('designation').trim().isLength({ min: 1 }).withMessage('Designation is required'),
  body('stockQty').isFloat({ min: 0 }).withMessage('Stock quantity must be non-negative'),
  body('unit').trim().isLength({ min: 1 }).withMessage('Unit is required'),
  body('condition').isIn(['OK', 'NON_CONFORME', 'MAUVAIS']).withMessage('Invalid condition'),
  body('location').trim().isLength({ min: 1 }).withMessage('Location is required')
];

const updateInventoryItemValidation = [
  body('owner').optional().trim().isLength({ min: 1 }).withMessage('Owner cannot be empty'),
  body('family').optional().trim().isLength({ min: 1 }).withMessage('Family cannot be empty'),
  body('subFamily').optional().trim(),
  body('designation').optional().trim().isLength({ min: 1 }).withMessage('Designation cannot be empty'),
  body('stockQty').optional().isFloat({ min: 0 }).withMessage('Stock quantity must be non-negative'),
  body('unit').optional().trim().isLength({ min: 1 }).withMessage('Unit cannot be empty'),
  body('condition').optional().isIn(['OK', 'NON_CONFORME', 'MAUVAIS']).withMessage('Invalid condition'),
  body('location').optional().trim().isLength({ min: 1 }).withMessage('Location cannot be empty')
];

// Get all inventory items
router.get('/', authenticateToken, async (req, res) => {
  try {
    const { page = 1, limit = 10, condition, family, search, location } = req.query;
    const skip = (page - 1) * limit;

    let whereClause = {};

    // Filter by condition if provided
    if (condition) {
      whereClause.condition = condition;
    }

    // Filter by family if provided
    if (family) {
      whereClause.family = family;
    }

    // Filter by location if provided
    if (location) {
      whereClause.location = {
        contains: location,
        mode: 'insensitive'
      };
    }

    // Search functionality
    if (search) {
      whereClause.OR = [
        { designation: { contains: search, mode: 'insensitive' } },
        { owner: { contains: search, mode: 'insensitive' } },
        { family: { contains: search, mode: 'insensitive' } },
        { subFamily: { contains: search, mode: 'insensitive' } }
      ];
    }

    const inventoryItems = await prisma.inventoryItem.findMany({
      where: whereClause,
      orderBy: [
        { family: 'asc' },
        { subFamily: 'asc' },
        { designation: 'asc' }
      ],
      skip: parseInt(skip),
      take: parseInt(limit)
    });

    const total = await prisma.inventoryItem.count({ where: whereClause });

    res.json({
      inventoryItems,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get inventory items error:', error);
    res.status(500).json({
      error: 'Failed to retrieve inventory items',
      message: 'An error occurred while fetching inventory items'
    });
  }
});

// Get single inventory item
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const inventoryItem = await prisma.inventoryItem.findUnique({
      where: { id }
    });

    if (!inventoryItem) {
      return res.status(404).json({
        error: 'Inventory Item Not Found',
        message: 'The requested inventory item was not found'
      });
    }

    res.json({ inventoryItem });
  } catch (error) {
    console.error('Get inventory item error:', error);
    res.status(500).json({
      error: 'Failed to retrieve inventory item',
      message: 'An error occurred while fetching the inventory item'
    });
  }
});

// Create new inventory item
router.post('/', authenticateToken, requireRole(['ADMIN', 'SUPERVISOR']), createInventoryItemValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { owner, family, subFamily, designation, stockQty, unit, condition, location } = req.body;

    const inventoryItem = await prisma.inventoryItem.create({
      data: {
        owner,
        family,
        subFamily,
        designation,
        stockQty,
        unit,
        condition,
        location,
        lastChecked: new Date()
      }
    });

    res.status(201).json({
      message: 'Inventory item created successfully',
      inventoryItem
    });
  } catch (error) {
    console.error('Create inventory item error:', error);
    res.status(500).json({
      error: 'Failed to create inventory item',
      message: 'An error occurred while creating the inventory item'
    });
  }
});

// Update inventory item
router.put('/:id', authenticateToken, requireRole(['ADMIN', 'SUPERVISOR']), updateInventoryItemValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation Error',
        details: errors.array()
      });
    }

    const { id } = req.params;
    const updateData = req.body;

    // Check if inventory item exists
    const existingItem = await prisma.inventoryItem.findUnique({
      where: { id }
    });

    if (!existingItem) {
      return res.status(404).json({
        error: 'Inventory Item Not Found',
        message: 'The requested inventory item was not found'
      });
    }

    // Update last checked date
    updateData.lastChecked = new Date();

    const inventoryItem = await prisma.inventoryItem.update({
      where: { id },
      data: updateData
    });

    res.json({
      message: 'Inventory item updated successfully',
      inventoryItem
    });
  } catch (error) {
    console.error('Update inventory item error:', error);
    res.status(500).json({
      error: 'Failed to update inventory item',
      message: 'An error occurred while updating the inventory item'
    });
  }
});

// Delete inventory item
router.delete('/:id', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  try {
    const { id } = req.params;

    const inventoryItem = await prisma.inventoryItem.findUnique({
      where: { id }
    });

    if (!inventoryItem) {
      return res.status(404).json({
        error: 'Inventory Item Not Found',
        message: 'The requested inventory item was not found'
      });
    }

    await prisma.inventoryItem.delete({
      where: { id }
    });

    res.json({
      message: 'Inventory item deleted successfully'
    });
  } catch (error) {
    console.error('Delete inventory item error:', error);
    res.status(500).json({
      error: 'Failed to delete inventory item',
      message: 'An error occurred while deleting the inventory item'
    });
  }
});

// Get inventory alerts (items with non-conforming condition)
router.get('/alerts/conditions', authenticateToken, async (req, res) => {
  try {
    const { page = 1, limit = 10 } = req.query;
    const skip = (page - 1) * limit;

    const alertItems = await prisma.inventoryItem.findMany({
      where: {
        condition: {
          in: ['NON_CONFORME', 'MAUVAIS']
        }
      },
      orderBy: [
        { condition: 'desc' },
        { lastChecked: 'asc' }
      ],
      skip: parseInt(skip),
      take: parseInt(limit)
    });

    const total = await prisma.inventoryItem.count({
      where: {
        condition: {
          in: ['NON_CONFORME', 'MAUVAIS']
        }
      }
    });

    res.json({
      alertItems,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get inventory alerts error:', error);
    res.status(500).json({
      error: 'Failed to retrieve inventory alerts',
      message: 'An error occurred while fetching inventory alerts'
    });
  }
});

// Get inventory statistics
router.get('/statistics/overview', authenticateToken, async (req, res) => {
  try {
    // Get total counts
    const totalItems = await prisma.inventoryItem.count();
    const okItems = await prisma.inventoryItem.count({
      where: { condition: 'OK' }
    });
    const nonConformeItems = await prisma.inventoryItem.count({
      where: { condition: 'NON_CONFORME' }
    });
    const mauvaisItems = await prisma.inventoryItem.count({
      where: { condition: 'MAUVAIS' }
    });

    // Get family distribution
    const familyStats = await prisma.inventoryItem.groupBy({
      by: ['family'],
      _count: {
        family: true
      }
    });

    // Get condition distribution
    const conditionStats = await prisma.inventoryItem.groupBy({
      by: ['condition'],
      _count: {
        condition: true
      }
    });

    // Get location distribution
    const locationStats = await prisma.inventoryItem.groupBy({
      by: ['location'],
      _count: {
        location: true
      }
    });

    // Get items that need checking (not checked in last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const itemsNeedingCheck = await prisma.inventoryItem.count({
      where: {
        lastChecked: {
          lt: thirtyDaysAgo
        }
      }
    });

    res.json({
      overview: {
        totalItems,
        okItems,
        nonConformeItems,
        mauvaisItems,
        itemsNeedingCheck
      },
      distributions: {
        families: familyStats,
        conditions: conditionStats,
        locations: locationStats
      }
    });
  } catch (error) {
    console.error('Get inventory statistics error:', error);
    res.status(500).json({
      error: 'Failed to retrieve inventory statistics',
      message: 'An error occurred while fetching inventory statistics'
    });
  }
});

// Bulk update inventory items
router.post('/bulk-update', authenticateToken, requireRole(['ADMIN', 'SUPERVISOR']), async (req, res) => {
  try {
    const { items } = req.body;

    if (!Array.isArray(items) || items.length === 0) {
      return res.status(400).json({
        error: 'Invalid Data',
        message: 'Items array is required and must not be empty'
      });
    }

    const results = await prisma.$transaction(async (tx) => {
      const updates = [];

      for (const item of items) {
        const { id, stockQty, condition, location } = item;

        if (!id) {
          throw new Error('Item ID is required for bulk update');
        }

        const updateData = {
          lastChecked: new Date()
        };

        if (stockQty !== undefined) updateData.stockQty = stockQty;
        if (condition) updateData.condition = condition;
        if (location) updateData.location = location;

        const updatedItem = await tx.inventoryItem.update({
          where: { id },
          data: updateData
        });

        updates.push(updatedItem);
      }

      return updates;
    });

    res.json({
      message: `${results.length} inventory items updated successfully`,
      updatedItems: results
    });
  } catch (error) {
    console.error('Bulk update inventory error:', error);
    res.status(500).json({
      error: 'Failed to bulk update inventory items',
      message: error.message || 'An error occurred while updating inventory items'
    });
  }
});

// Get inventory families (for dropdown)
router.get('/families/list', authenticateToken, async (req, res) => {
  try {
    const families = await prisma.inventoryItem.groupBy({
      by: ['family'],
      _count: {
        family: true
      },
      orderBy: {
        family: 'asc'
      }
    });

    const familyList = families.map(f => ({
      family: f.family,
      count: f._count.family
    }));

    res.json({ families: familyList });
  } catch (error) {
    console.error('Get inventory families error:', error);
    res.status(500).json({
      error: 'Failed to retrieve inventory families',
      message: 'An error occurred while fetching inventory families'
    });
  }
});

// Get inventory locations (for dropdown)
router.get('/locations/list', authenticateToken, async (req, res) => {
  try {
    const locations = await prisma.inventoryItem.groupBy({
      by: ['location'],
      _count: {
        location: true
      },
      orderBy: {
        location: 'asc'
      }
    });

    const locationList = locations.map(l => ({
      location: l.location,
      count: l._count.location
    }));

    res.json({ locations: locationList });
  } catch (error) {
    console.error('Get inventory locations error:', error);
    res.status(500).json({
      error: 'Failed to retrieve inventory locations',
      message: 'An error occurred while fetching inventory locations'
    });
  }
});

module.exports = router; 

# ==== src/routes/reservations.js ====

// src/routes/reservations.js

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const { authenticateToken, requireRole, requireOwnershipOrAdmin } = require('../middleware/auth');
const { sendReservationStatusEmail, sendProjectAssignmentEmail } = require('../utils/email');

const router = express.Router();
const prisma = new PrismaClient();

// Validation schemas
const createReservationValidation = [
  body('fieldId').notEmpty().withMessage('Field ID is required'),
  body('surfaceM2Requested').isFloat({ min: 0.1 }).withMessage('Surface area must be greater than 0'),
  body('startRequested').isISO8601().withMessage('Start date must be a valid date'),
  body('endRequested').isISO8601().withMessage('End date must be a valid date'),
];

const updateReservationValidation = [
  body('status').isIn(['APPROVED', 'REJECTED']).withMessage('Status must be APPROVED or REJECTED'),
  body('supervisorId').optional().isUUID().withMessage('Supervisor ID must be a valid UUID')
];

// Get all reservations (filtered by user role)
router.get('/', authenticateToken, async (req, res) => {
  try {
    const { page = 1, limit = 10, status, fieldId } = req.query;
    const skip = (page - 1) * limit;

    let whereClause = {};
    if (status) whereClause.status = status;
    if (fieldId) whereClause.fieldId = fieldId;

    if (req.user.role === 'CLIENT') {
      whereClause.clientId = req.user.id;
    } else if (req.user.role === 'SUPERVISOR') {
      whereClause.supervisorId = req.user.id;
    }

    const reservations = await prisma.reservation.findMany({
      where: whereClause,
      include: {
        client: {
          select: { id: true, name: true, email: true, entity: { select: { id: true, name: true, notes: true } } }
        },
        field: {
          select: { id: true, name: true, location: true, totalSurfaceM2: true, freeSurfaceM2: true }
        },
        supervisor: {
          select: { id: true, name: true, email: true }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: parseInt(skip),
      take: parseInt(limit)
    });

    const total = await prisma.reservation.count({ where: whereClause });

    res.json({
      reservations,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get reservations error:', error);
    res.status(500).json({ error: 'Failed to retrieve reservations', message: 'An error occurred while fetching reservations' });
  }
});

// Get single reservation
router.get('/:id', authenticateToken, requireOwnershipOrAdmin('reservation'), async (req, res) => {
  try {
    const { id } = req.params;
    const reservation = await prisma.reservation.findUnique({
      where: { id },
      include: {
        client: { select: { id: true, name: true, email: true, entity: { select: { id: true, name: true } } } },
        field: { select: { id: true, name: true, location: true, totalSurfaceM2: true, freeSurfaceM2: true, status: true } },
        supervisor: { select: { id: true, name: true, email: true } }
      }
    });

    if (!reservation) {
      return res.status(404).json({ error: 'Reservation Not Found', message: 'The requested reservation was not found' });
    }
    res.json({ reservation });
  } catch (error) {
    console.error('Get reservation error:', error);
    res.status(500).json({ error: 'Failed to retrieve reservation', message: 'An error occurred while fetching the reservation' });
  }
});

// Create new reservation
router.post('/', authenticateToken, requireRole('CLIENT'), createReservationValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ error: 'Validation Error', details: errors.array() });
    }

    const { fieldId, surfaceM2Requested, startRequested, endRequested } = req.body;
    const field = await prisma.field.findUnique({ where: { id: fieldId } });

    if (!field) {
      return res.status(404).json({ error: 'Field Not Found' });
    }
    if (field.status !== 'ACTIVE') {
      return res.status(400).json({ error: 'Field Not Available' });
    }
    if (surfaceM2Requested > field.freeSurfaceM2) {
      return res.status(400).json({ error: 'Insufficient Surface Area' });
    }
    
    const reservation = await prisma.reservation.create({
      data: {
        clientId: req.user.id,
        fieldId,
        surfaceM2Requested: parseFloat(surfaceM2Requested),
        startRequested: new Date(startRequested),
        endRequested: new Date(endRequested),
        status: 'PENDING'
      },
    });

    res.status(201).json({ message: 'Reservation request created successfully', reservation });
  } catch (error) {
    console.error('Create reservation error:', error);
    res.status(500).json({ error: 'Failed to create reservation', message: 'An error occurred while creating the reservation' });
  }
});

// Update reservation status (approve/reject) - SIMPLIFIED FOR DEMO
router.patch('/:id/status', authenticateToken, requireRole('ADMIN'), updateReservationValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ error: 'Validation Error', details: errors.array() });
    }

    const { id } = req.params;
    const { status, supervisorId } = req.body;

    const reservation = await prisma.reservation.findUnique({
      where: { id },
      include: {
        client: { select: { name: true, email: true } },
        field: { select: { id: true, freeSurfaceM2: true } }
      }
    });

    if (!reservation) {
      return res.status(404).json({ error: 'Reservation Not Found' });
    }
    if (reservation.status !== 'PENDING') {
      return res.status(400).json({ error: 'Only pending reservations can be changed' });
    }

    const result = await prisma.$transaction(async (tx) => {
      const updatedReservation = await tx.reservation.update({
        where: { id },
        data: { status, decisionDate: new Date(), supervisorId: status === 'APPROVED' ? supervisorId : null }
      });

      if (status === 'APPROVED') {
        await tx.field.update({
          where: { id: reservation.fieldId },
          data: { freeSurfaceM2: { decrement: reservation.surfaceM2Requested } }
        });
      }

      try {
        await sendReservationStatusEmail(
          reservation.client.email,
          reservation,
          status,
          `Your reservation request for ${reservation.surfaceM2Requested}m¬≤`
        );
      } catch (emailError) {
        console.error('Failed to send notification email:', emailError);
      }

      return updatedReservation;
    });

    res.json({ message: `Reservation ${status.toLowerCase()} successfully`, reservation: result });
  } catch (error) {
    console.error('Update reservation status error:', error);
    res.status(500).json({ error: 'Failed to update reservation status', message: 'An error occurred while updating the reservation status' });
  }
});

// Delete reservation (only if pending)
router.delete('/:id', authenticateToken, requireOwnershipOrAdmin('reservation'), async (req, res) => {
  try {
    const { id } = req.params;
    const reservation = await prisma.reservation.findUnique({ where: { id } });

    if (!reservation) {
      return res.status(404).json({ error: 'Reservation Not Found' });
    }
    if (reservation.status !== 'PENDING') {
      return res.status(400).json({ error: 'Cannot Delete Reservation' });
    }

    await prisma.reservation.delete({ where: { id } });
    res.json({ message: 'Reservation deleted successfully' });
  } catch (error) {
    console.error('Delete reservation error:', error);
    res.status(500).json({ error: 'Failed to delete reservation', message: 'An error occurred while deleting the reservation' });
  }
});

module.exports = router;

# ==== src/routes/dashboard.js ====

const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { authenticateToken, requireRole } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

// Get admin dashboard overview
router.get('/admin', authenticateToken, requireRole('ADMIN'), async (req, res) => {
  try {
    // Get pending reservations count
    const pendingReservations = await prisma.reservation.count({
      where: { status: 'PENDING' }
    });

    // Get inventory items that need attention
    const inventoryAlerts = await prisma.inventoryItem.count({
      where: {
        condition: {
          in: ['NON_CONFORME', 'MAUVAIS']
        }
      }
    });

    // Get outstanding price offers
    const outstandingOffers = await prisma.priceOffer.count({
      where: {
        status: {
          in: ['PENDING', 'SENT']
        }
      }
    });

    // Get service orders in progress
    const serviceOrdersInProgress = await prisma.serviceOrder.count({
      where: { status: 'IN_PROGRESS' }
    });

    // Get field utilization overview
    const fields = await prisma.field.findMany({
      include: {
        projects: {
          where: {
            status: {
              in: ['EN_COURS', 'PROGRAMME', 'A_LANCER']
            }
          }
        }
      }
    });

    const fieldUtilization = fields.map(field => {
      const usedSurface = field.projects.reduce((sum, project) => sum + project.surfaceM2, 0);
      const utilizationPercentage = (usedSurface / field.totalSurfaceM2) * 100;
      
      return {
        id: field.id,
        name: field.name,
        totalSurfaceM2: field.totalSurfaceM2,
        usedSurfaceM2: usedSurface,
        freeSurfaceM2: field.freeSurfaceM2,
        utilizationPercentage: Math.round(utilizationPercentage * 100) / 100,
        status: field.status
      };
    });

    // Get recent projects
    const recentProjects = await prisma.project.findMany({
      take: 10,
      orderBy: {
        createdAt: 'desc'
      },
      include: {
        client: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        supervisor: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        field: {
          select: {
            id: true,
            name: true
          }
        },
        activityType: {
          select: {
            id: true,
            label: true
          }
        }
      }
    });

    // Get project status distribution
    const projectStatusStats = await prisma.project.groupBy({
      by: ['status'],
      _count: {
        status: true
      }
    });

    // Get monthly project trends
    const monthlyTrends = await prisma.project.groupBy({
      by: ['startDate'],
      _count: {
        id: true
      },
      where: {
        startDate: {
          gte: new Date(new Date().getFullYear(), 0, 1) // From January 1st of current year
        }
      }
    });

    // Get activity type distribution
    const activityTypeStats = await prisma.project.groupBy({
      by: ['activityTypeId'],
      _count: {
        id: true
      },
      include: {
        activityType: {
          select: {
            label: true
          }
        }
      }
    });

    res.json({
      overview: {
        pendingReservations,
        inventoryAlerts,
        outstandingOffers,
        serviceOrdersInProgress
      },
      fieldUtilization,
      recentProjects,
      statistics: {
        projectStatusDistribution: projectStatusStats,
        monthlyTrends,
        activityTypeDistribution: activityTypeStats
      }
    });
  } catch (error) {
    console.error('Get admin dashboard error:', error);
    res.status(500).json({
      error: 'Failed to retrieve admin dashboard',
      message: 'An error occurred while fetching dashboard data'
    });
  }
});

// Get supervisor dashboard
router.get('/supervisor', authenticateToken, requireRole('SUPERVISOR'), async (req, res) => {
  try {
    // Get assigned projects
    const assignedProjects = await prisma.project.findMany({
      where: {
        supervisorId: req.user.id
      },
      include: {
        client: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        field: {
          select: {
            id: true,
            name: true,
            location: true
          }
        },
        activityType: {
          select: {
            id: true,
            label: true
          }
        }
      },
      orderBy: {
        startDate: 'desc'
      }
    });

    // Get project statistics for supervisor
    const projectStats = await prisma.project.groupBy({
      by: ['status'],
      _count: {
        status: true
      },
      where: {
        supervisorId: req.user.id
      }
    });

    // Get upcoming deadlines (projects ending in next 30 days)
    const upcomingDeadlines = await prisma.project.findMany({
      where: {
        supervisorId: req.user.id,
        endDate: {
          gte: new Date(),
          lte: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // Next 30 days
        },
        status: {
          in: ['EN_COURS', 'PROGRAMME', 'A_LANCER']
        }
      },
      include: {
        client: {
          select: {
            name: true,
            email: true
          }
        },
        field: {
          select: {
            name: true
          }
        }
      },
      orderBy: {
        endDate: 'asc'
      }
    });

    res.json({
      assignedProjects,
      projectStatistics: projectStats,
      upcomingDeadlines
    });
  } catch (error) {
    console.error('Get supervisor dashboard error:', error);
    res.status(500).json({
      error: 'Failed to retrieve supervisor dashboard',
      message: 'An error occurred while fetching dashboard data'
    });
  }
});

// Get client dashboard
router.get('/client', authenticateToken, requireRole('CLIENT'), async (req, res) => {
  try {
    // Get client's reservations
    const reservations = await prisma.reservation.findMany({
      where: {
        clientId: req.user.id
      },
      include: {
        field: {
          select: {
            id: true,
            name: true,
            location: true
          }
        },
        supervisor: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        project: {
          select: {
            id: true,
            title: true,
            status: true,
            progressNotes: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    // Get client's projects
    const projects = await prisma.project.findMany({
      where: {
        clientId: req.user.id
      },
      include: {
        supervisor: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        field: {
          select: {
            id: true,
            name: true,
            location: true
          }
        },
        activityType: {
          select: {
            id: true,
            label: true
          }
        }
      },
      orderBy: {
        startDate: 'desc'
      }
    });

    // Get reservation statistics
    const reservationStats = await prisma.reservation.groupBy({
      by: ['status'],
      _count: {
        status: true
      },
      where: {
        clientId: req.user.id
      }
    });

    // Get project statistics
    const projectStats = await prisma.project.groupBy({
      by: ['status'],
      _count: {
        status: true
      },
      where: {
        clientId: req.user.id
      }
    });

    res.json({
      reservations,
      projects,
      statistics: {
        reservationStatusDistribution: reservationStats,
        projectStatusDistribution: projectStats
      }
    });
  } catch (error) {
    console.error('Get client dashboard error:', error);
    res.status(500).json({
      error: 'Failed to retrieve client dashboard',
      message: 'An error occurred while fetching dashboard data'
    });
  }
});

// Get general statistics (for all users)
router.get('/statistics', authenticateToken, async (req, res) => {
  try {
    // Get total counts
    const totalFields = await prisma.field.count();
    const totalProjects = await prisma.project.count();
    const totalUsers = await prisma.user.count();
    const totalReservations = await prisma.reservation.count();

    // Get active counts
    const activeFields = await prisma.field.count({
      where: { status: 'ACTIVE' }
    });

    const activeProjects = await prisma.project.count({
      where: {
        status: {
          in: ['EN_COURS', 'PROGRAMME', 'A_LANCER']
        }
      }
    });

    const pendingReservations = await prisma.reservation.count({
      where: { status: 'PENDING' }
    });

    // Get user role distribution
    const userRoleStats = await prisma.user.groupBy({
      by: ['role'],
      _count: {
        role: true
      }
    });

    // Get project status distribution
    const projectStatusStats = await prisma.project.groupBy({
      by: ['status'],
      _count: {
        status: true
      }
    });

    // Get field utilization summary
    const fields = await prisma.field.findMany({
      include: {
        projects: {
          where: {
            status: {
              in: ['EN_COURS', 'PROGRAMME', 'A_LANCER']
            }
          }
        }
      }
    });

    const totalSurfaceM2 = fields.reduce((sum, field) => sum + field.totalSurfaceM2, 0);
    const usedSurfaceM2 = fields.reduce((sum, field) => {
      const usedSurface = field.projects.reduce((projectSum, project) => projectSum + project.surfaceM2, 0);
      return sum + usedSurface;
    }, 0);

    const overallUtilizationPercentage = totalSurfaceM2 > 0 ? (usedSurfaceM2 / totalSurfaceM2) * 100 : 0;

    res.json({
      overview: {
        totalFields,
        activeFields,
        totalProjects,
        activeProjects,
        totalUsers,
        totalReservations,
        pendingReservations,
        totalSurfaceM2,
        usedSurfaceM2,
        overallUtilizationPercentage: Math.round(overallUtilizationPercentage * 100) / 100
      },
      distributions: {
        userRoles: userRoleStats,
        projectStatus: projectStatusStats
      }
    });
  } catch (error) {
    console.error('Get statistics error:', error);
    res.status(500).json({
      error: 'Failed to retrieve statistics',
      message: 'An error occurred while fetching statistics'
    });
  }
});

// Get timeline data for projects
router.get('/timeline', authenticateToken, async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    
    let whereClause = {};
    
    if (startDate && endDate) {
      whereClause.OR = [
        {
          startDate: {
            gte: new Date(startDate),
            lte: new Date(endDate)
          }
        },
        {
          endDate: {
            gte: new Date(startDate),
            lte: new Date(endDate)
          }
        }
      ];
    }

    // Add role-based filtering
    if (req.user.role === 'CLIENT') {
      whereClause.clientId = req.user.id;
    } else if (req.user.role === 'SUPERVISOR') {
      whereClause.supervisorId = req.user.id;
    }
    // ADMIN can see all projects

    const projects = await prisma.project.findMany({
      where: whereClause,
      include: {
        client: {
          select: {
            id: true,
            name: true
          }
        },
        supervisor: {
          select: {
            id: true,
            name: true
          }
        },
        field: {
          select: {
            id: true,
            name: true
          }
        },
        activityType: {
          select: {
            id: true,
            label: true
          }
        }
      },
      orderBy: {
        startDate: 'asc'
      }
    });

    // Format timeline data
    const timelineData = projects.map(project => ({
      id: project.id,
      title: project.title,
      start: project.startDate,
      end: project.endDate || new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // If no end date, set to 1 year from now
      status: project.status,
      client: project.client.name,
      supervisor: project.supervisor.name,
      field: project.field.name,
      activityType: project.activityType?.label,
      surfaceM2: project.surfaceM2
    }));

    res.json({
      timeline: timelineData
    });
  } catch (error) {
    console.error('Get timeline error:', error);
    res.status(500).json({
      error: 'Failed to retrieve timeline',
      message: 'An error occurred while fetching timeline data'
    });
  }
});

module.exports = router; 

# ==== src/routes/serviceOrders.js ====

const express = require('express');
const { body, validationResult } = require('express-validator');
const { PrismaClient } = require('@prisma/client');
const { authenticateToken, requireRole } = require('../middleware/auth');
const { generateServiceOrderPDF } = require('../utils/pdfGenerator');

const router = express.Router();
const prisma = new PrismaClient();

// Validation schemas
const createServiceOrderValidation = [
  body('objet').trim().notEmpty().withMessage('Objet is required'),
  body('marketNumber').optional().trim(),
  body('bcNumber').optional().trim(),
  body('startDate').isISO8601().withMessage('Start date must be a valid date'),
  body('clientRep').trim().notEmpty().withMessage('Client representative is required'),
  body('supplier').trim().notEmpty().withMessage('Supplier is required')
];

const updateServiceOrderValidation = [
  body('objet').optional().trim().notEmpty().withMessage('Objet cannot be empty'),
  body('marketNumber').optional().trim(),
  body('bcNumber').optional().trim(),
  body('startDate').optional().isISO8601().withMessage('Start date must be a valid date'),
  body('clientRep').optional().trim().notEmpty().withMessage('Client representative cannot be empty'),
  body('supplier').optional().trim().notEmpty().withMessage('Supplier cannot be empty'),
  body('status').optional().isIn(['IN_PROGRESS', 'COMPLETED', 'CANCELLED']).withMessage('Invalid status')
];

// Get all service orders (Admin only)
router.get('/', authenticateToken, requireRole(['ADMIN']), async (req, res) => {
  try {
    const { page = 1, limit = 10, status, supplier, startDate, endDate } = req.query;
    const skip = (page - 1) * limit;

    // Build filter conditions
    const where = {};
    if (status) where.status = status;
    if (supplier) where.supplier = { contains: supplier, mode: 'insensitive' };
    if (startDate || endDate) {
      where.startDate = {};
      if (startDate) where.startDate.gte = new Date(startDate);
      if (endDate) where.startDate.lte = new Date(endDate);
    }

    const [serviceOrders, total] = await Promise.all([
      prisma.serviceOrder.findMany({
        where,
        include: {
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip: parseInt(skip),
        take: parseInt(limit)
      }),
      prisma.serviceOrder.count({ where })
    ]);

    res.json({
      serviceOrders,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Error fetching service orders:', error);
    res.status(500).json({ error: 'Failed to fetch service orders' });
  }
});

// Get service order by ID
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { role, userId } = req.user;

    const serviceOrder = await prisma.serviceOrder.findUnique({
      where: { id },
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    if (!serviceOrder) {
      return res.status(404).json({ error: 'Service order not found' });
    }

    // Only admin or creator can view
    if (role !== 'ADMIN' && serviceOrder.createdById !== userId) {
      return res.status(403).json({ error: 'Access denied' });
    }

    res.json(serviceOrder);
  } catch (error) {
    console.error('Error fetching service order:', error);
    res.status(500).json({ error: 'Failed to fetch service order' });
  }
});

// Create new service order (Admin only)
router.post('/', authenticateToken, requireRole(['ADMIN']), createServiceOrderValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { objet, marketNumber, bcNumber, startDate, clientRep, supplier } = req.body;
    const { userId } = req.user;

    const serviceOrder = await prisma.serviceOrder.create({
      data: {
        objet,
        marketNumber,
        bcNumber,
        startDate: new Date(startDate),
        clientRep,
        supplier,
        createdById: userId
      },
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    res.status(201).json(serviceOrder);
  } catch (error) {
    console.error('Error creating service order:', error);
    res.status(500).json({ error: 'Failed to create service order' });
  }
});

// Update service order
router.put('/:id', authenticateToken, requireRole(['ADMIN']), updateServiceOrderValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { id } = req.params;
    const updateData = { ...req.body };
    
    if (updateData.startDate) {
      updateData.startDate = new Date(updateData.startDate);
    }

    const serviceOrder = await prisma.serviceOrder.update({
      where: { id },
      data: updateData,
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    res.json(serviceOrder);
  } catch (error) {
    console.error('Error updating service order:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Service order not found' });
    }
    res.status(500).json({ error: 'Failed to update service order' });
  }
});

// Delete service order (Admin only)
router.delete('/:id', authenticateToken, requireRole(['ADMIN']), async (req, res) => {
  try {
    const { id } = req.params;

    await prisma.serviceOrder.delete({
      where: { id }
    });

    res.json({ message: 'Service order deleted successfully' });
  } catch (error) {
    console.error('Error deleting service order:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Service order not found' });
    }
    res.status(500).json({ error: 'Failed to delete service order' });
  }
});

// Generate PDF for service order
router.get('/:id/pdf', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { role, userId } = req.user;

    const serviceOrder = await prisma.serviceOrder.findUnique({
      where: { id },
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    if (!serviceOrder) {
      return res.status(404).json({ error: 'Service order not found' });
    }

    // Only admin or creator can generate PDF
    if (role !== 'ADMIN' && serviceOrder.createdById !== userId) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const pdfBuffer = await generateServiceOrderPDF(serviceOrder);

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="service-order-${id}.pdf"`);
    res.send(pdfBuffer);
  } catch (error) {
    console.error('Error generating PDF:', error);
    res.status(500).json({ error: 'Failed to generate PDF' });
  }
});

// Get service order statistics
router.get('/stats/overview', authenticateToken, requireRole(['ADMIN']), async (req, res) => {
  try {
    const [total, inProgress, completed, cancelled] = await Promise.all([
      prisma.serviceOrder.count(),
      prisma.serviceOrder.count({ where: { status: 'IN_PROGRESS' } }),
      prisma.serviceOrder.count({ where: { status: 'COMPLETED' } }),
      prisma.serviceOrder.count({ where: { status: 'CANCELLED' } })
    ]);

    const monthlyStats = await prisma.serviceOrder.groupBy({
      by: ['status'],
      _count: {
        status: true
      },
      where: {
        createdAt: {
          gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1)
        }
      }
    });

    res.json({
      total,
      inProgress,
      completed,
      cancelled,
      monthlyStats
    });
  } catch (error) {
    console.error('Error fetching service order statistics:', error);
    res.status(500).json({ error: 'Failed to fetch statistics' });
  }
});

// Update service order status
router.patch('/:id/status', authenticateToken, requireRole(['ADMIN']), [
  body('status').isIn(['IN_PROGRESS', 'COMPLETED', 'CANCELLED']).withMessage('Invalid status')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { id } = req.params;
    const { status } = req.body;

    const serviceOrder = await prisma.serviceOrder.update({
      where: { id },
      data: { status },
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    res.json(serviceOrder);
  } catch (error) {
    console.error('Error updating service order status:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Service order not found' });
    }
    res.status(500).json({ error: 'Failed to update status' });
  }
});

module.exports = router; 

# ==== src/services/api.ts ====

import axios from 'axios';

const api = axios.create({
  baseURL: process.env.REACT_APP_API_BASE_URL,
  withCredentials: true,
});

// Add a request interceptor to include JWT token if present
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

export default api; 

